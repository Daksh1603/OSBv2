/* tslint:disable */
/* eslint-disable */
/**
 * Workspaces manager API
 * Opensource Brain Platform - Reference Workspaces manager API
 *
 * The version of the OpenAPI document: 0.2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * dandi repository resource
 * @export
 * @interface DandiRepositoryResource
 */
export interface DandiRepositoryResource {
    /**
     * file name
     * @type {string}
     * @memberof DandiRepositoryResource
     */
    name?: string;
    /**
     * Download URL of the Resource
     * @type {string}
     * @memberof DandiRepositoryResource
     */
    path?: string;
    /**
     * OSB Repository id
     * @type {number}
     * @memberof DandiRepositoryResource
     */
    osbrepository_id?: number;
    /**
     * File size in bytes of the RepositoryResource
     * @type {number}
     * @memberof DandiRepositoryResource
     */
    size?: number;
    /**
     * Date/time the ReposityResource is last modified
     * @type {string}
     * @memberof DandiRepositoryResource
     */
    timestamp_modified?: string;
}
/**
 * Download Resource (files/folders)
 * @export
 * @interface DownloadResource
 */
export interface DownloadResource {
    /**
     * file name
     * @type {string}
     * @memberof DownloadResource
     */
    name?: string;
    /**
     * Download URL of the Resource
     * @type {string}
     * @memberof DownloadResource
     */
    path?: string;
}
/**
 * figshare repository resource
 * @export
 * @interface FigshareRepositoryResource
 */
export interface FigshareRepositoryResource {
    /**
     * file name
     * @type {string}
     * @memberof FigshareRepositoryResource
     */
    name?: string;
    /**
     * Download URL of the Resource
     * @type {string}
     * @memberof FigshareRepositoryResource
     */
    path?: string;
    /**
     * OSB Repository id
     * @type {number}
     * @memberof FigshareRepositoryResource
     */
    osbrepository_id?: number;
    /**
     * File size in bytes of the RepositoryResource
     * @type {number}
     * @memberof FigshareRepositoryResource
     */
    size?: number;
    /**
     * Date/time the ReposityResource is last modified
     * @type {string}
     * @memberof FigshareRepositoryResource
     */
    timestamp_modified?: string;
}
/**
 * github repository resource
 * @export
 * @interface GITRepositoryResource
 */
export interface GITRepositoryResource {
    /**
     * file name
     * @type {string}
     * @memberof GITRepositoryResource
     */
    name?: string;
    /**
     * Download URL of the Resource
     * @type {string}
     * @memberof GITRepositoryResource
     */
    path?: string;
    /**
     * OSB Repository id
     * @type {number}
     * @memberof GITRepositoryResource
     */
    osbrepository_id?: number;
    /**
     * File size in bytes of the RepositoryResource
     * @type {number}
     * @memberof GITRepositoryResource
     */
    size?: number;
    /**
     * Date/time the ReposityResource is last modified
     * @type {string}
     * @memberof GITRepositoryResource
     */
    timestamp_modified?: string;
    /**
     * The GIT ref
     * @type {string}
     * @memberof GITRepositoryResource
     */
    ref?: string;
    /**
     * The GIT sha of the resource
     * @type {string}
     * @memberof GITRepositoryResource
     */
    sha?: string;
}
/**
 * GIT hub specific attributes of the RepositoryResource
 * @export
 * @interface GITRepositoryResourceAllOf
 */
export interface GITRepositoryResourceAllOf {
    /**
     * The GIT ref
     * @type {string}
     * @memberof GITRepositoryResourceAllOf
     */
    ref?: string;
    /**
     * The GIT sha of the resource
     * @type {string}
     * @memberof GITRepositoryResourceAllOf
     */
    sha?: string;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {Array<ResourceOrigin>}
     * @memberof InlineObject
     */
    resourceorigins?: Array<ResourceOrigin>;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {Pagination}
     * @memberof InlineResponse200
     */
    pagination?: Pagination;
    /**
     * 
     * @type {Array<Workspace>}
     * @memberof InlineResponse200
     */
    workspaces?: Array<Workspace>;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {Pagination}
     * @memberof InlineResponse2001
     */
    pagination?: Pagination;
    /**
     * 
     * @type {Array<OSBRepository>}
     * @memberof InlineResponse2001
     */
    osbrepositories?: Array<OSBRepository>;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {Pagination}
     * @memberof InlineResponse2002
     */
    pagination?: Pagination;
    /**
     * 
     * @type {Array<VolumeStorage>}
     * @memberof InlineResponse2002
     */
    volumestorages?: Array<VolumeStorage>;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {Pagination}
     * @memberof InlineResponse2003
     */
    pagination?: Pagination;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof InlineResponse2003
     */
    tags?: Array<Tag>;
}
/**
 * OSBRepository extended model
 * @export
 * @interface OSBRepository
 */
export interface OSBRepository {
    /**
     * 
     * @type {number}
     * @memberof OSBRepository
     */
    id?: number;
    /**
     * Repository name.
     * @type {string}
     * @memberof OSBRepository
     */
    name: string;
    /**
     * Summary describing the OSB Repository
     * @type {string}
     * @memberof OSBRepository
     */
    summary?: string;
    /**
     * 
     * @type {RepositoryType}
     * @memberof OSBRepository
     */
    repository_type: RepositoryType;
    /**
     * List of Repository Content Types
     * @type {string}
     * @memberof OSBRepository
     */
    content_types: string;
    /**
     * Auto sync of the resources
     * @type {boolean}
     * @memberof OSBRepository
     */
    auto_sync?: boolean;
    /**
     * URI of the repository
     * @type {string}
     * @memberof OSBRepository
     */
    uri: string;
    /**
     * The default branch to show for this repository
     * @type {string}
     * @memberof OSBRepository
     */
    default_context?: string;
    /**
     * OSBRepository keycloak user id, will be automatically be set to the logged in user
     * @type {string}
     * @memberof OSBRepository
     */
    user_id?: string;
    /**
     * Date/time the Workspace is created
     * @type {string}
     * @memberof OSBRepository
     */
    timestamp_created?: string;
    /**
     * Date/time the Workspace is last updated
     * @type {string}
     * @memberof OSBRepository
     */
    timestamp_updated?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof OSBRepository
     */
    tags?: Array<Tag>;
    /**
     * 
     * @type {RepositoryResourceNode}
     * @memberof OSBRepository
     */
    context_resources?: RepositoryResourceNode;
    /**
     * 
     * @type {Array<string>}
     * @memberof OSBRepository
     */
    contexts?: Array<string>;
    /**
     * 
     * @type {User}
     * @memberof OSBRepository
     */
    user?: User;
    /**
     * 
     * @type {Array<RepositoryContentType>}
     * @memberof OSBRepository
     */
    content_types_list?: Array<RepositoryContentType>;
    /**
     * Repository description
     * @type {string}
     * @memberof OSBRepository
     */
    description?: string;
    /**
     * Date/time the OSBReposity is last modified
     * @type {string}
     * @memberof OSBRepository
     */
    timestamp_modified?: string;
}
/**
 * extra attributes
 * @export
 * @interface OSBRepositoryAllOf
 */
export interface OSBRepositoryAllOf {
    /**
     * 
     * @type {RepositoryResourceNode}
     * @memberof OSBRepositoryAllOf
     */
    context_resources?: RepositoryResourceNode;
    /**
     * 
     * @type {Array<string>}
     * @memberof OSBRepositoryAllOf
     */
    contexts?: Array<string>;
    /**
     * 
     * @type {User}
     * @memberof OSBRepositoryAllOf
     */
    user?: User;
    /**
     * 
     * @type {Array<RepositoryContentType>}
     * @memberof OSBRepositoryAllOf
     */
    content_types_list?: Array<RepositoryContentType>;
    /**
     * Repository description
     * @type {string}
     * @memberof OSBRepositoryAllOf
     */
    description?: string;
    /**
     * Date/time the OSBReposity is last modified
     * @type {string}
     * @memberof OSBRepositoryAllOf
     */
    timestamp_modified?: string;
}
/**
 * OSB Repository Base model
 * @export
 * @interface OSBRepositoryBase
 */
export interface OSBRepositoryBase {
    /**
     * 
     * @type {number}
     * @memberof OSBRepositoryBase
     */
    id?: number;
    /**
     * Repository name.
     * @type {string}
     * @memberof OSBRepositoryBase
     */
    name: string;
    /**
     * Summary describing the OSB Repository
     * @type {string}
     * @memberof OSBRepositoryBase
     */
    summary?: string;
    /**
     * 
     * @type {RepositoryType}
     * @memberof OSBRepositoryBase
     */
    repository_type: RepositoryType;
    /**
     * List of Repository Content Types
     * @type {string}
     * @memberof OSBRepositoryBase
     */
    content_types: string;
    /**
     * Auto sync of the resources
     * @type {boolean}
     * @memberof OSBRepositoryBase
     */
    auto_sync?: boolean;
    /**
     * URI of the repository
     * @type {string}
     * @memberof OSBRepositoryBase
     */
    uri: string;
    /**
     * The default branch to show for this repository
     * @type {string}
     * @memberof OSBRepositoryBase
     */
    default_context?: string;
    /**
     * OSBRepository keycloak user id, will be automatically be set to the logged in user
     * @type {string}
     * @memberof OSBRepositoryBase
     */
    user_id?: string;
    /**
     * Date/time the Workspace is created
     * @type {string}
     * @memberof OSBRepositoryBase
     */
    timestamp_created?: string;
    /**
     * Date/time the Workspace is last updated
     * @type {string}
     * @memberof OSBRepositoryBase
     */
    timestamp_updated?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof OSBRepositoryBase
     */
    tags?: Array<Tag>;
}
/**
 * OSB Repository model
 * @export
 * @interface OSBRepositoryEntity
 */
export interface OSBRepositoryEntity {
    /**
     * 
     * @type {number}
     * @memberof OSBRepositoryEntity
     */
    id?: number;
    /**
     * Repository name.
     * @type {string}
     * @memberof OSBRepositoryEntity
     */
    name: string;
    /**
     * Summary describing the OSB Repository
     * @type {string}
     * @memberof OSBRepositoryEntity
     */
    summary?: string;
    /**
     * 
     * @type {RepositoryType}
     * @memberof OSBRepositoryEntity
     */
    repository_type: RepositoryType;
    /**
     * List of Repository Content Types
     * @type {string}
     * @memberof OSBRepositoryEntity
     */
    content_types: string;
    /**
     * Auto sync of the resources
     * @type {boolean}
     * @memberof OSBRepositoryEntity
     */
    auto_sync?: boolean;
    /**
     * URI of the repository
     * @type {string}
     * @memberof OSBRepositoryEntity
     */
    uri: string;
    /**
     * The default branch to show for this repository
     * @type {string}
     * @memberof OSBRepositoryEntity
     */
    default_context?: string;
    /**
     * OSBRepository keycloak user id, will be automatically be set to the logged in user
     * @type {string}
     * @memberof OSBRepositoryEntity
     */
    user_id?: string;
    /**
     * Date/time the Workspace is created
     * @type {string}
     * @memberof OSBRepositoryEntity
     */
    timestamp_created?: string;
    /**
     * Date/time the Workspace is last updated
     * @type {string}
     * @memberof OSBRepositoryEntity
     */
    timestamp_updated?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof OSBRepositoryEntity
     */
    tags?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface Pagination
 */
export interface Pagination {
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    current_page?: number;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    number_of_pages?: number;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    total?: number;
}
/**
 * Repository Content type:   * experimental - Experimental data   * modeling - Modeling 
 * @export
 * @enum {string}
 */
export enum RepositoryContentType {
    Experimental = 'experimental',
    Modeling = 'modeling'
}

/**
 * 
 * @export
 * @interface RepositoryInfo
 */
export interface RepositoryInfo {
    /**
     * 
     * @type {Array<string>}
     * @memberof RepositoryInfo
     */
    contexts?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RepositoryInfo
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof RepositoryInfo
     */
    summary?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RepositoryInfo
     */
    tags?: Array<string>;
}
/**
 * @type RepositoryResource
 * Repository resource
 * @export
 */
export type RepositoryResource = DandiRepositoryResource | FigshareRepositoryResource | GITRepositoryResource;

/**
 * Resource (files/folders) of an OSBRepository
 * @export
 * @interface RepositoryResourceBase
 */
export interface RepositoryResourceBase {
    /**
     * file name
     * @type {string}
     * @memberof RepositoryResourceBase
     */
    name?: string;
    /**
     * Download URL of the Resource
     * @type {string}
     * @memberof RepositoryResourceBase
     */
    path?: string;
    /**
     * OSB Repository id
     * @type {number}
     * @memberof RepositoryResourceBase
     */
    osbrepository_id?: number;
    /**
     * File size in bytes of the RepositoryResource
     * @type {number}
     * @memberof RepositoryResourceBase
     */
    size?: number;
    /**
     * Date/time the ReposityResource is last modified
     * @type {string}
     * @memberof RepositoryResourceBase
     */
    timestamp_modified?: string;
}
/**
 * GIT hub specific attributes of the RepositoryResource
 * @export
 * @interface RepositoryResourceBaseAllOf
 */
export interface RepositoryResourceBaseAllOf {
    /**
     * OSB Repository id
     * @type {number}
     * @memberof RepositoryResourceBaseAllOf
     */
    osbrepository_id?: number;
    /**
     * File size in bytes of the RepositoryResource
     * @type {number}
     * @memberof RepositoryResourceBaseAllOf
     */
    size?: number;
    /**
     * Date/time the ReposityResource is last modified
     * @type {string}
     * @memberof RepositoryResourceBaseAllOf
     */
    timestamp_modified?: string;
}
/**
 * Tree node (files/folders) of a Repository tree
 * @export
 * @interface RepositoryResourceNode
 */
export interface RepositoryResourceNode {
    /**
     * 
     * @type {RepositoryResource}
     * @memberof RepositoryResourceNode
     */
    resource?: RepositoryResource;
    /**
     * 
     * @type {Array<RepositoryResourceNode>}
     * @memberof RepositoryResourceNode
     */
    children?: Array<RepositoryResourceNode>;
}
/**
 * Repository type:   * dandi - DANDI repository   * figshare - FigShare repository   * github - Github repository 
 * @export
 * @enum {string}
 */
export enum RepositoryType {
    Dandi = 'dandi',
    Figshare = 'figshare',
    Github = 'github'
}

/**
 * Resource Base
 * @export
 * @interface ResourceBase
 */
export interface ResourceBase {
    /**
     * file name
     * @type {string}
     * @memberof ResourceBase
     */
    name?: string;
    /**
     * Download URL of the Resource
     * @type {string}
     * @memberof ResourceBase
     */
    path?: string;
}
/**
 * @type ResourceOrigin
 * optional Resource where the WorkspaceResource is build from
 * @export
 */
export type ResourceOrigin = DownloadResource | RepositoryResource;

/**
 * Resource status:  * a - Available  * e - Error, not available  * p - Pending 
 * @export
 * @enum {string}
 */
export enum ResourceStatus {
    A = 'a',
    E = 'e',
    P = 'p'
}

/**
 * Resource type:  * e - Experimental  * m - Model  * g - Generic  * u - Unknown (to be defined) 
 * @export
 * @enum {string}
 */
export enum ResourceType {
    E = 'e',
    M = 'm',
    G = 'g',
    U = 'u'
}

/**
 * Tags
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {number}
     * @memberof Tag
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    tag?: string;
}
/**
 * Keycloak User
 * @export
 * @interface User
 */
export interface User {
    /**
     * Keycloak user id
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     * First Name of the keycloak user
     * @type {string}
     * @memberof User
     */
    first_name?: string;
    /**
     * Last Name of the keycloak user
     * @type {string}
     * @memberof User
     */
    last_name?: string;
    /**
     * Username of the keycloak user
     * @type {string}
     * @memberof User
     */
    username?: string;
    /**
     * Email address of the keycloak user
     * @type {string}
     * @memberof User
     */
    email?: string;
}
/**
 * 
 * @export
 * @interface Valid
 */
export interface Valid {
    /**
     * 
     * @type {string}
     * @memberof Valid
     */
    response?: string;
}
/**
 * Volume which can be connected to a workspace
 * @export
 * @interface VolumeStorage
 */
export interface VolumeStorage {
    /**
     * 
     * @type {number}
     * @memberof VolumeStorage
     */
    id?: number;
    /**
     * StorageVolume name
     * @type {string}
     * @memberof VolumeStorage
     */
    name: string;
}
/**
 * Workspace extended
 * @export
 * @interface Workspace
 */
export interface Workspace {
    /**
     * 
     * @type {number}
     * @memberof Workspace
     */
    id?: number;
    /**
     * Workspace name.
     * @type {string}
     * @memberof Workspace
     */
    name: string;
    /**
     * Workspace description.
     * @type {string}
     * @memberof Workspace
     */
    description: string;
    /**
     * Date/time the Workspace is created
     * @type {string}
     * @memberof Workspace
     */
    timestamp_created?: string;
    /**
     * Date/time the Workspace is last updated
     * @type {string}
     * @memberof Workspace
     */
    timestamp_updated?: string;
    /**
     * The workspace resource id the workspace is opened last with
     * @type {number}
     * @memberof Workspace
     */
    last_opened_resource_id?: number;
    /**
     * 
     * @type {string}
     * @memberof Workspace
     */
    thumbnail?: string;
    /**
     * Gallery with images of the workspace
     * @type {Array<WorkspaceImage>}
     * @memberof Workspace
     */
    gallery?: Array<WorkspaceImage>;
    /**
     * Workspace keycloak user id, will be automatically be set to the logged in user
     * @type {string}
     * @memberof Workspace
     */
    user_id?: string;
    /**
     * Is this a public workspace? Default false
     * @type {boolean}
     * @memberof Workspace
     */
    publicable?: boolean;
    /**
     * Is this a featured workspace? Default false
     * @type {boolean}
     * @memberof Workspace
     */
    featured?: boolean;
    /**
     * Workspace license
     * @type {string}
     * @memberof Workspace
     */
    license?: string;
    /**
     * Collaborators who work on the workspace
     * @type {Array<WorkspaceCollaborator>}
     * @memberof Workspace
     */
    collaborators?: Array<WorkspaceCollaborator>;
    /**
     * 
     * @type {VolumeStorage}
     * @memberof Workspace
     */
    storage?: VolumeStorage;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Workspace
     */
    tags?: Array<Tag>;
    /**
     * Resources of the workspace
     * @type {Array<WorkspaceResource>}
     * @memberof Workspace
     */
    resources?: Array<WorkspaceResource>;
    /**
     * 
     * @type {User}
     * @memberof Workspace
     */
    user?: User;
}
/**
 * extra attributes
 * @export
 * @interface WorkspaceAllOf
 */
export interface WorkspaceAllOf {
    /**
     * Resources of the workspace
     * @type {Array<WorkspaceResource>}
     * @memberof WorkspaceAllOf
     */
    resources?: Array<WorkspaceResource>;
    /**
     * 
     * @type {User}
     * @memberof WorkspaceAllOf
     */
    user?: User;
}
/**
 * Workspace item
 * @export
 * @interface WorkspaceBase
 */
export interface WorkspaceBase {
    /**
     * 
     * @type {number}
     * @memberof WorkspaceBase
     */
    id?: number;
    /**
     * Workspace name.
     * @type {string}
     * @memberof WorkspaceBase
     */
    name: string;
    /**
     * Workspace description.
     * @type {string}
     * @memberof WorkspaceBase
     */
    description: string;
    /**
     * Date/time the Workspace is created
     * @type {string}
     * @memberof WorkspaceBase
     */
    timestamp_created?: string;
    /**
     * Date/time the Workspace is last updated
     * @type {string}
     * @memberof WorkspaceBase
     */
    timestamp_updated?: string;
    /**
     * The workspace resource id the workspace is opened last with
     * @type {number}
     * @memberof WorkspaceBase
     */
    last_opened_resource_id?: number;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceBase
     */
    thumbnail?: string;
    /**
     * Gallery with images of the workspace
     * @type {Array<WorkspaceImage>}
     * @memberof WorkspaceBase
     */
    gallery?: Array<WorkspaceImage>;
    /**
     * Workspace keycloak user id, will be automatically be set to the logged in user
     * @type {string}
     * @memberof WorkspaceBase
     */
    user_id?: string;
    /**
     * Is this a public workspace? Default false
     * @type {boolean}
     * @memberof WorkspaceBase
     */
    publicable?: boolean;
    /**
     * Is this a featured workspace? Default false
     * @type {boolean}
     * @memberof WorkspaceBase
     */
    featured?: boolean;
    /**
     * Workspace license
     * @type {string}
     * @memberof WorkspaceBase
     */
    license?: string;
    /**
     * Collaborators who work on the workspace
     * @type {Array<WorkspaceCollaborator>}
     * @memberof WorkspaceBase
     */
    collaborators?: Array<WorkspaceCollaborator>;
    /**
     * 
     * @type {VolumeStorage}
     * @memberof WorkspaceBase
     */
    storage?: VolumeStorage;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof WorkspaceBase
     */
    tags?: Array<Tag>;
}
/**
 * Workspace Collaborator of a workspace
 * @export
 * @interface WorkspaceCollaborator
 */
export interface WorkspaceCollaborator {
    /**
     * 
     * @type {number}
     * @memberof WorkspaceCollaborator
     */
    id?: number;
    /**
     * Workspace Collaborator keycloak user id
     * @type {string}
     * @memberof WorkspaceCollaborator
     */
    user_id: string;
}
/**
 * Workspace model
 * @export
 * @interface WorkspaceEntity
 */
export interface WorkspaceEntity {
    /**
     * 
     * @type {number}
     * @memberof WorkspaceEntity
     */
    id?: number;
    /**
     * Workspace name.
     * @type {string}
     * @memberof WorkspaceEntity
     */
    name: string;
    /**
     * Workspace description.
     * @type {string}
     * @memberof WorkspaceEntity
     */
    description: string;
    /**
     * Date/time the Workspace is created
     * @type {string}
     * @memberof WorkspaceEntity
     */
    timestamp_created?: string;
    /**
     * Date/time the Workspace is last updated
     * @type {string}
     * @memberof WorkspaceEntity
     */
    timestamp_updated?: string;
    /**
     * The workspace resource id the workspace is opened last with
     * @type {number}
     * @memberof WorkspaceEntity
     */
    last_opened_resource_id?: number;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceEntity
     */
    thumbnail?: string;
    /**
     * Gallery with images of the workspace
     * @type {Array<WorkspaceImage>}
     * @memberof WorkspaceEntity
     */
    gallery?: Array<WorkspaceImage>;
    /**
     * Workspace keycloak user id, will be automatically be set to the logged in user
     * @type {string}
     * @memberof WorkspaceEntity
     */
    user_id?: string;
    /**
     * Is this a public workspace? Default false
     * @type {boolean}
     * @memberof WorkspaceEntity
     */
    publicable?: boolean;
    /**
     * Is this a featured workspace? Default false
     * @type {boolean}
     * @memberof WorkspaceEntity
     */
    featured?: boolean;
    /**
     * Workspace license
     * @type {string}
     * @memberof WorkspaceEntity
     */
    license?: string;
    /**
     * Collaborators who work on the workspace
     * @type {Array<WorkspaceCollaborator>}
     * @memberof WorkspaceEntity
     */
    collaborators?: Array<WorkspaceCollaborator>;
    /**
     * 
     * @type {VolumeStorage}
     * @memberof WorkspaceEntity
     */
    storage?: VolumeStorage;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof WorkspaceEntity
     */
    tags?: Array<Tag>;
    /**
     * Resources of the workspace
     * @type {Array<WorkspaceResourceEntity>}
     * @memberof WorkspaceEntity
     */
    resources?: Array<WorkspaceResourceEntity>;
}
/**
 * 
 * @export
 * @interface WorkspaceEntityAllOf
 */
export interface WorkspaceEntityAllOf {
    /**
     * Resources of the workspace
     * @type {Array<WorkspaceResourceEntity>}
     * @memberof WorkspaceEntityAllOf
     */
    resources?: Array<WorkspaceResourceEntity>;
}
/**
 * Workspace images of a workspace
 * @export
 * @interface WorkspaceImage
 */
export interface WorkspaceImage {
    /**
     * 
     * @type {number}
     * @memberof WorkspaceImage
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceImage
     */
    image: string;
}
/**
 * Workspace Resource item of a Workspace
 * @export
 * @interface WorkspaceResource
 */
export interface WorkspaceResource {
    /**
     * 
     * @type {number}
     * @memberof WorkspaceResource
     */
    id?: number;
    /**
     * WorkspaceResource name
     * @type {string}
     * @memberof WorkspaceResource
     */
    name: string;
    /**
     * WorkspaceResource folder where the resource will stored in the pvc
     * @type {string}
     * @memberof WorkspaceResource
     */
    folder?: string;
    /**
     * 
     * @type {ResourceStatus}
     * @memberof WorkspaceResource
     */
    status?: ResourceStatus;
    /**
     * Date/time of creation of the WorkspaceResource
     * @type {string}
     * @memberof WorkspaceResource
     */
    timestamp_created?: string;
    /**
     * Date/time of last updating of the WorkspaceResource
     * @type {string}
     * @memberof WorkspaceResource
     */
    timestamp_updated?: string;
    /**
     * Date/time of last opening of the WorkspaceResource
     * @type {string}
     * @memberof WorkspaceResource
     */
    timestamp_last_opened?: string;
    /**
     * 
     * @type {ResourceType}
     * @memberof WorkspaceResource
     */
    resource_type: ResourceType;
    /**
     * workspace_id
     * @type {number}
     * @memberof WorkspaceResource
     */
    workspace_id?: number;
    /**
     * 
     * @type {ResourceOrigin}
     * @memberof WorkspaceResource
     */
    origin?: ResourceOrigin;
}
/**
 * 
 * @export
 * @interface WorkspaceResourceAllOf
 */
export interface WorkspaceResourceAllOf {
    /**
     * workspace_id
     * @type {number}
     * @memberof WorkspaceResourceAllOf
     */
    workspace_id?: number;
    /**
     * 
     * @type {ResourceOrigin}
     * @memberof WorkspaceResourceAllOf
     */
    origin?: ResourceOrigin;
}
/**
 * 
 * @export
 * @interface WorkspaceResourceBase
 */
export interface WorkspaceResourceBase {
    /**
     * 
     * @type {number}
     * @memberof WorkspaceResourceBase
     */
    id?: number;
    /**
     * WorkspaceResource name
     * @type {string}
     * @memberof WorkspaceResourceBase
     */
    name: string;
    /**
     * WorkspaceResource folder where the resource will stored in the pvc
     * @type {string}
     * @memberof WorkspaceResourceBase
     */
    folder?: string;
    /**
     * 
     * @type {ResourceStatus}
     * @memberof WorkspaceResourceBase
     */
    status?: ResourceStatus;
    /**
     * Date/time of creation of the WorkspaceResource
     * @type {string}
     * @memberof WorkspaceResourceBase
     */
    timestamp_created?: string;
    /**
     * Date/time of last updating of the WorkspaceResource
     * @type {string}
     * @memberof WorkspaceResourceBase
     */
    timestamp_updated?: string;
    /**
     * Date/time of last opening of the WorkspaceResource
     * @type {string}
     * @memberof WorkspaceResourceBase
     */
    timestamp_last_opened?: string;
    /**
     * 
     * @type {ResourceType}
     * @memberof WorkspaceResourceBase
     */
    resource_type: ResourceType;
}
/**
 * Workspace Resource item of a Workspace
 * @export
 * @interface WorkspaceResourceEntity
 */
export interface WorkspaceResourceEntity {
    /**
     * 
     * @type {number}
     * @memberof WorkspaceResourceEntity
     */
    id?: number;
    /**
     * WorkspaceResource name
     * @type {string}
     * @memberof WorkspaceResourceEntity
     */
    name: string;
    /**
     * WorkspaceResource folder where the resource will stored in the pvc
     * @type {string}
     * @memberof WorkspaceResourceEntity
     */
    folder?: string;
    /**
     * 
     * @type {ResourceStatus}
     * @memberof WorkspaceResourceEntity
     */
    status?: ResourceStatus;
    /**
     * Date/time of creation of the WorkspaceResource
     * @type {string}
     * @memberof WorkspaceResourceEntity
     */
    timestamp_created?: string;
    /**
     * Date/time of last updating of the WorkspaceResource
     * @type {string}
     * @memberof WorkspaceResourceEntity
     */
    timestamp_updated?: string;
    /**
     * Date/time of last opening of the WorkspaceResource
     * @type {string}
     * @memberof WorkspaceResourceEntity
     */
    timestamp_last_opened?: string;
    /**
     * 
     * @type {ResourceType}
     * @memberof WorkspaceResourceEntity
     */
    resource_type: ResourceType;
    /**
     * Origin data JSON formatted of the WorkspaceResource
     * @type {string}
     * @memberof WorkspaceResourceEntity
     */
    origin?: string;
    /**
     * workspace_id
     * @type {number}
     * @memberof WorkspaceResourceEntity
     */
    workspace_id?: number;
}
/**
 * 
 * @export
 * @interface WorkspaceResourceEntityAllOf
 */
export interface WorkspaceResourceEntityAllOf {
    /**
     * Origin data JSON formatted of the WorkspaceResource
     * @type {string}
     * @memberof WorkspaceResourceEntityAllOf
     */
    origin?: string;
    /**
     * workspace_id
     * @type {number}
     * @memberof WorkspaceResourceEntityAllOf
     */
    workspace_id?: number;
}

/**
 * K8sApi - axios parameter creator
 * @export
 */
export const K8sApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Test if application is healthy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        live: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/live`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Test if application is ready to take requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ready: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ready`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * K8sApi - functional programming interface
 * @export
 */
export const K8sApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = K8sApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Test if application is healthy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async live(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.live(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Test if application is ready to take requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ready(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ready(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * K8sApi - factory interface
 * @export
 */
export const K8sApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = K8sApiFp(configuration)
    return {
        /**
         * 
         * @summary Test if application is healthy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        live(options?: any): AxiosPromise<string> {
            return localVarFp.live(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Test if application is ready to take requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ready(options?: any): AxiosPromise<string> {
            return localVarFp.ready(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * K8sApi - object-oriented interface
 * @export
 * @class K8sApi
 * @extends {BaseAPI}
 */
export class K8sApi extends BaseAPI {
    /**
     * 
     * @summary Test if application is healthy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof K8sApi
     */
    public live(options?: any) {
        return K8sApiFp(this.configuration).live(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Test if application is ready to take requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof K8sApi
     */
    public ready(options?: any) {
        return K8sApiFp(this.configuration).ready(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RestApi - axios parameter creator
 * @export
 */
export const RestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a Workspace Image from the workspace.
         * @param {number} id Workspace ID of the workspace
         * @param {number} imageId Workspace Image Id to be deleted from the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delimage: async (id: number, imageId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('delimage', 'id', id)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('delimage', 'imageId', imageId)
            const localVarPath = `/workspace/{id}/gallery/{image_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"image_id"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to retrieve description for a repository.
         * @param {string} uri 
         * @param {RepositoryType} repositoryType 
         * @param {string} context 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDescription: async (uri: string, repositoryType: RepositoryType, context: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uri' is not null or undefined
            assertParamExists('getDescription', 'uri', uri)
            // verify required parameter 'repositoryType' is not null or undefined
            assertParamExists('getDescription', 'repositoryType', repositoryType)
            // verify required parameter 'context' is not null or undefined
            assertParamExists('getDescription', 'context', context)
            const localVarPath = `/osbrepository/description`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (uri !== undefined) {
                localVarQueryParameter['uri'] = uri;
            }

            if (repositoryType !== undefined) {
                localVarQueryParameter['repository_type'] = repositoryType;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to retrieve a list of contexts of a repository.
         * @param {string} uri 
         * @param {RepositoryType} repositoryType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo: async (uri: string, repositoryType: RepositoryType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uri' is not null or undefined
            assertParamExists('getInfo', 'uri', uri)
            // verify required parameter 'repositoryType' is not null or undefined
            assertParamExists('getInfo', 'repositoryType', repositoryType)
            const localVarPath = `/osbrepository/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (uri !== undefined) {
                localVarQueryParameter['uri'] = uri;
            }

            if (repositoryType !== undefined) {
                localVarQueryParameter['repository_type'] = repositoryType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to list all available repositories.
         * @param {number} [page] The page number for starting to collect the result set.
         * @param {number} [perPage] The number of items to return.
         * @param {string} [q] The search string for filtering of the items to return. Format [field/relation[field]][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]. Multiple parameters are concatenated with + (OR operator)
         * @param {string} [tags] The tags to filter with Multiple parameters are concatenated with + (OR operator)
         * @param {string} [types] The tags to filter with Multiple parameters are concatenated with + (OR operator)
         * @param {string} [userId] The id of the owner user to filter with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osbrepositoryGet: async (page?: number, perPage?: number, q?: string, tags?: string, types?: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/osbrepository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (types !== undefined) {
                localVarQueryParameter['types'] = types;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a OSBRepository.
         * @param {number} id 
         * @param {string} [context] the context for getting the resources, optional
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osbrepositoryIdDelete: async (id: number, context?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osbrepositoryIdDelete', 'id', id)
            const localVarPath = `/osbrepository/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to retrieve a repository.
         * @param {number} id 
         * @param {string} [context] the context for getting the resources, optional
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osbrepositoryIdGet: async (id: number, context?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osbrepositoryIdGet', 'id', id)
            const localVarPath = `/osbrepository/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a OSB repository.
         * @param {number} id 
         * @param {OSBRepository} oSBRepository The repository to save.
         * @param {string} [context] the context for getting the resources, optional
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osbrepositoryIdPut: async (id: number, oSBRepository: OSBRepository, context?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osbrepositoryIdPut', 'id', id)
            // verify required parameter 'oSBRepository' is not null or undefined
            assertParamExists('osbrepositoryIdPut', 'oSBRepository', oSBRepository)
            const localVarPath = `/osbrepository/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oSBRepository, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to save a OSB Repository. The user_id (keycloak user id) will be automatically filled with the current user
         * @param {OSBRepository} oSBRepository The OSB repository to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osbrepositoryPost: async (oSBRepository: OSBRepository, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'oSBRepository' is not null or undefined
            assertParamExists('osbrepositoryPost', 'oSBRepository', oSBRepository)
            const localVarPath = `/osbrepository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oSBRepository, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to list all available tags.
         * @param {number} [page] The page number for starting to collect the result set.
         * @param {number} [perPage] The number of items to return.
         * @param {string} [q] The search string for filtering of the items to return. Format [field/relation[field]][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGet: async (page?: number, perPage?: number, q?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an tag from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagIdDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tagIdDelete', 'id', id)
            const localVarPath = `/tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to retrieve an tag from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagIdGet: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tagIdGet', 'id', id)
            const localVarPath = `/tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an tag in the repository.
         * @param {number} id 
         * @param {Tag} tag The tag to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagIdPut: async (id: number, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tagIdPut', 'id', id)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('tagIdPut', 'tag', tag)
            const localVarPath = `/tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to save a Tag to the repository. The user_id (keycloak user id) will be automatically filled with the current user
         * @param {Tag} tag The Tag to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagPost: async (tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('tagPost', 'tag', tag)
            const localVarPath = `/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to list all available volumestorages.
         * @param {number} [page] The page number for starting to collect the result set.
         * @param {number} [perPage] The number of items to return.
         * @param {string} [q] The search string for filtering of the items to return. Format [field/relation[field]][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumestorageGet: async (page?: number, perPage?: number, q?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/volumestorage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an volumestorage from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumestorageIdDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('volumestorageIdDelete', 'id', id)
            const localVarPath = `/volumestorage/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to retrieve an volumestorage from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumestorageIdGet: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('volumestorageIdGet', 'id', id)
            const localVarPath = `/volumestorage/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an volumestorage in the repository.
         * @param {number} id 
         * @param {VolumeStorage} volumeStorage The volumestorage to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumestorageIdPut: async (id: number, volumeStorage: VolumeStorage, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('volumestorageIdPut', 'id', id)
            // verify required parameter 'volumeStorage' is not null or undefined
            assertParamExists('volumestorageIdPut', 'volumeStorage', volumeStorage)
            const localVarPath = `/volumestorage/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(volumeStorage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to save a VolumeStorage to the repository. The user_id (keycloak user id) will be automatically filled with the current user
         * @param {VolumeStorage} volumeStorage The VolumeStorage to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumestoragePost: async (volumeStorage: VolumeStorage, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'volumeStorage' is not null or undefined
            assertParamExists('volumestoragePost', 'volumeStorage', volumeStorage)
            const localVarPath = `/volumestorage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(volumeStorage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to list all available workspaces.
         * @param {number} [page] The page number for starting to collect the result set.
         * @param {number} [perPage] The number of items to return.
         * @param {string} [q] The search string for filtering of the items to return. Multiple criteria are seperated by \&#39;+\&#39; (and operator is applied). Format [field/relation[field]][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]
         * @param {string} [tags] The tags to filter with Multiple parameters are concatenated with + (OR operator)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceGet: async (page?: number, perPage?: number, q?: string, tags?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/workspace`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a workspace from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceIdDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workspaceIdDelete', 'id', id)
            const localVarPath = `/workspace/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to retrieve a workspace from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceIdGet: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workspaceIdGet', 'id', id)
            const localVarPath = `/workspace/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a workspace in the repository.
         * @param {number} id 
         * @param {Workspace} workspace The workspace to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceIdPut: async (id: number, workspace: Workspace, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workspaceIdPut', 'id', id)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspaceIdPut', 'workspace', workspace)
            const localVarPath = `/workspace/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspace, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to save a Workspace to the repository. The user_id (keycloak user id) will be automatically filled with the current user
         * @param {Workspace} workspace The Workspace to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacePost: async (workspace: Workspace, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('workspacePost', 'workspace', workspace)
            const localVarPath = `/workspace`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspace, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a WorkspaceResource.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceresourceIdDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workspaceresourceIdDelete', 'id', id)
            const localVarPath = `/workspaceresource/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to retrieve a WorkspaceResource.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceresourceIdGet: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workspaceresourceIdGet', 'id', id)
            const localVarPath = `/workspaceresource/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the WorkspaceResource.
         * @param {number} id 
         * @param {WorkspaceResource} workspaceResource The WorkspaceResource to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceresourceIdPut: async (id: number, workspaceResource: WorkspaceResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workspaceresourceIdPut', 'id', id)
            // verify required parameter 'workspaceResource' is not null or undefined
            assertParamExists('workspaceresourceIdPut', 'workspaceResource', workspaceResource)
            const localVarPath = `/workspaceresource/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceResource, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to save a WorkspaceResource to the repository.
         * @param {WorkspaceResource} workspaceResource The WorkspaceResource to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceresourcePost: async (workspaceResource: WorkspaceResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceResource' is not null or undefined
            assertParamExists('workspaceresourcePost', 'workspaceResource', workspaceResource)
            const localVarPath = `/workspaceresource`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceResource, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds and image to the workspace.
         * @param {number} id Workspace ID of the workspace
         * @param {any} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesControllersWorkspaceControllerAddimage: async (id: number, image?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workspacesControllersWorkspaceControllerAddimage', 'id', id)
            const localVarPath = `/workspace/{id}/gallery`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Imports the ResourceOrigins into the Workspace and creates/updates the workspace resources
         * @param {number} id Workspace ID of the workspace
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesControllersWorkspaceControllerImportResources: async (id: number, inlineObject?: InlineObject, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workspacesControllersWorkspaceControllerImportResources', 'id', id)
            const localVarPath = `/workspace/{id}/import`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sets the thumbnail of the workspace.
         * @param {number} id Workspace ID of the workspace
         * @param {any} [thumbNail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesControllersWorkspaceControllerSetthumbnail: async (id: number, thumbNail?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workspacesControllersWorkspaceControllerSetthumbnail', 'id', id)
            const localVarPath = `/workspace/{id}/thumbnail`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (thumbNail !== undefined) { 
                localVarFormParams.append('thumbNail', thumbNail as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Clones a workspace
         * @param {number} id Workspace ID of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesControllersWorkspaceControllerWorkspaceClone: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workspacesControllersWorkspaceControllerWorkspaceClone', 'id', id)
            const localVarPath = `/workspace/{id}/clone`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to register a WorkspaceResource open action. The WorkspaceResource timestamp last open will be updated
         * @param {number} id WorkspaceResource ID of the WorkspaceResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesControllersWorkspaceResourceControllerOpen: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workspacesControllersWorkspaceResourceControllerOpen', 'id', id)
            const localVarPath = `/workspaceresource/{id}/open`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RestApi - functional programming interface
 * @export
 */
export const RestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RestApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a Workspace Image from the workspace.
         * @param {number} id Workspace ID of the workspace
         * @param {number} imageId Workspace Image Id to be deleted from the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delimage(id: number, imageId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delimage(id, imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Used to retrieve description for a repository.
         * @param {string} uri 
         * @param {RepositoryType} repositoryType 
         * @param {string} context 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDescription(uri: string, repositoryType: RepositoryType, context: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDescription(uri, repositoryType, context, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Used to retrieve a list of contexts of a repository.
         * @param {string} uri 
         * @param {RepositoryType} repositoryType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInfo(uri: string, repositoryType: RepositoryType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInfo(uri, repositoryType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Used to list all available repositories.
         * @param {number} [page] The page number for starting to collect the result set.
         * @param {number} [perPage] The number of items to return.
         * @param {string} [q] The search string for filtering of the items to return. Format [field/relation[field]][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]. Multiple parameters are concatenated with + (OR operator)
         * @param {string} [tags] The tags to filter with Multiple parameters are concatenated with + (OR operator)
         * @param {string} [types] The tags to filter with Multiple parameters are concatenated with + (OR operator)
         * @param {string} [userId] The id of the owner user to filter with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osbrepositoryGet(page?: number, perPage?: number, q?: string, tags?: string, types?: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osbrepositoryGet(page, perPage, q, tags, types, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a OSBRepository.
         * @param {number} id 
         * @param {string} [context] the context for getting the resources, optional
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osbrepositoryIdDelete(id: number, context?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osbrepositoryIdDelete(id, context, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Used to retrieve a repository.
         * @param {number} id 
         * @param {string} [context] the context for getting the resources, optional
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osbrepositoryIdGet(id: number, context?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OSBRepository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osbrepositoryIdGet(id, context, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a OSB repository.
         * @param {number} id 
         * @param {OSBRepository} oSBRepository The repository to save.
         * @param {string} [context] the context for getting the resources, optional
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osbrepositoryIdPut(id: number, oSBRepository: OSBRepository, context?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OSBRepository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osbrepositoryIdPut(id, oSBRepository, context, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Used to save a OSB Repository. The user_id (keycloak user id) will be automatically filled with the current user
         * @param {OSBRepository} oSBRepository The OSB repository to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osbrepositoryPost(oSBRepository: OSBRepository, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OSBRepository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osbrepositoryPost(oSBRepository, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Used to list all available tags.
         * @param {number} [page] The page number for starting to collect the result set.
         * @param {number} [perPage] The number of items to return.
         * @param {string} [q] The search string for filtering of the items to return. Format [field/relation[field]][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagGet(page?: number, perPage?: number, q?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagGet(page, perPage, q, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an tag from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagIdDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Used to retrieve an tag from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagIdGet(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an tag in the repository.
         * @param {number} id 
         * @param {Tag} tag The tag to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagIdPut(id: number, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagIdPut(id, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Used to save a Tag to the repository. The user_id (keycloak user id) will be automatically filled with the current user
         * @param {Tag} tag The Tag to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagPost(tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagPost(tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Used to list all available volumestorages.
         * @param {number} [page] The page number for starting to collect the result set.
         * @param {number} [perPage] The number of items to return.
         * @param {string} [q] The search string for filtering of the items to return. Format [field/relation[field]][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async volumestorageGet(page?: number, perPage?: number, q?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.volumestorageGet(page, perPage, q, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an volumestorage from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async volumestorageIdDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.volumestorageIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Used to retrieve an volumestorage from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async volumestorageIdGet(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolumeStorage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.volumestorageIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an volumestorage in the repository.
         * @param {number} id 
         * @param {VolumeStorage} volumeStorage The volumestorage to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async volumestorageIdPut(id: number, volumeStorage: VolumeStorage, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolumeStorage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.volumestorageIdPut(id, volumeStorage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Used to save a VolumeStorage to the repository. The user_id (keycloak user id) will be automatically filled with the current user
         * @param {VolumeStorage} volumeStorage The VolumeStorage to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async volumestoragePost(volumeStorage: VolumeStorage, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolumeStorage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.volumestoragePost(volumeStorage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Used to list all available workspaces.
         * @param {number} [page] The page number for starting to collect the result set.
         * @param {number} [perPage] The number of items to return.
         * @param {string} [q] The search string for filtering of the items to return. Multiple criteria are seperated by \&#39;+\&#39; (and operator is applied). Format [field/relation[field]][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]
         * @param {string} [tags] The tags to filter with Multiple parameters are concatenated with + (OR operator)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspaceGet(page?: number, perPage?: number, q?: string, tags?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspaceGet(page, perPage, q, tags, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a workspace from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspaceIdDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspaceIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Used to retrieve a workspace from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspaceIdGet(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspaceIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a workspace in the repository.
         * @param {number} id 
         * @param {Workspace} workspace The workspace to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspaceIdPut(id: number, workspace: Workspace, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspaceIdPut(id, workspace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Used to save a Workspace to the repository. The user_id (keycloak user id) will be automatically filled with the current user
         * @param {Workspace} workspace The Workspace to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacePost(workspace: Workspace, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacePost(workspace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a WorkspaceResource.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspaceresourceIdDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspaceresourceIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Used to retrieve a WorkspaceResource.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspaceresourceIdGet(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspaceresourceIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the WorkspaceResource.
         * @param {number} id 
         * @param {WorkspaceResource} workspaceResource The WorkspaceResource to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspaceresourceIdPut(id: number, workspaceResource: WorkspaceResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspaceresourceIdPut(id, workspaceResource, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Used to save a WorkspaceResource to the repository.
         * @param {WorkspaceResource} workspaceResource The WorkspaceResource to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspaceresourcePost(workspaceResource: WorkspaceResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspaceresourcePost(workspaceResource, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Adds and image to the workspace.
         * @param {number} id Workspace ID of the workspace
         * @param {any} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesControllersWorkspaceControllerAddimage(id: number, image?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesControllersWorkspaceControllerAddimage(id, image, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Imports the ResourceOrigins into the Workspace and creates/updates the workspace resources
         * @param {number} id Workspace ID of the workspace
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesControllersWorkspaceControllerImportResources(id: number, inlineObject?: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesControllersWorkspaceControllerImportResources(id, inlineObject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sets the thumbnail of the workspace.
         * @param {number} id Workspace ID of the workspace
         * @param {any} [thumbNail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesControllersWorkspaceControllerSetthumbnail(id: number, thumbNail?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesControllersWorkspaceControllerSetthumbnail(id, thumbNail, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Clones a workspace
         * @param {number} id Workspace ID of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesControllersWorkspaceControllerWorkspaceClone(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesControllersWorkspaceControllerWorkspaceClone(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Used to register a WorkspaceResource open action. The WorkspaceResource timestamp last open will be updated
         * @param {number} id WorkspaceResource ID of the WorkspaceResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesControllersWorkspaceResourceControllerOpen(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesControllersWorkspaceResourceControllerOpen(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RestApi - factory interface
 * @export
 */
export const RestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RestApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a Workspace Image from the workspace.
         * @param {number} id Workspace ID of the workspace
         * @param {number} imageId Workspace Image Id to be deleted from the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delimage(id: number, imageId: number, options?: any): AxiosPromise<void> {
            return localVarFp.delimage(id, imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to retrieve description for a repository.
         * @param {string} uri 
         * @param {RepositoryType} repositoryType 
         * @param {string} context 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDescription(uri: string, repositoryType: RepositoryType, context: string, options?: any): AxiosPromise<string> {
            return localVarFp.getDescription(uri, repositoryType, context, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to retrieve a list of contexts of a repository.
         * @param {string} uri 
         * @param {RepositoryType} repositoryType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(uri: string, repositoryType: RepositoryType, options?: any): AxiosPromise<RepositoryInfo> {
            return localVarFp.getInfo(uri, repositoryType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to list all available repositories.
         * @param {number} [page] The page number for starting to collect the result set.
         * @param {number} [perPage] The number of items to return.
         * @param {string} [q] The search string for filtering of the items to return. Format [field/relation[field]][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]. Multiple parameters are concatenated with + (OR operator)
         * @param {string} [tags] The tags to filter with Multiple parameters are concatenated with + (OR operator)
         * @param {string} [types] The tags to filter with Multiple parameters are concatenated with + (OR operator)
         * @param {string} [userId] The id of the owner user to filter with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osbrepositoryGet(page?: number, perPage?: number, q?: string, tags?: string, types?: string, userId?: string, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.osbrepositoryGet(page, perPage, q, tags, types, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a OSBRepository.
         * @param {number} id 
         * @param {string} [context] the context for getting the resources, optional
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osbrepositoryIdDelete(id: number, context?: string, options?: any): AxiosPromise<void> {
            return localVarFp.osbrepositoryIdDelete(id, context, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to retrieve a repository.
         * @param {number} id 
         * @param {string} [context] the context for getting the resources, optional
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osbrepositoryIdGet(id: number, context?: string, options?: any): AxiosPromise<OSBRepository> {
            return localVarFp.osbrepositoryIdGet(id, context, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a OSB repository.
         * @param {number} id 
         * @param {OSBRepository} oSBRepository The repository to save.
         * @param {string} [context] the context for getting the resources, optional
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osbrepositoryIdPut(id: number, oSBRepository: OSBRepository, context?: string, options?: any): AxiosPromise<OSBRepository> {
            return localVarFp.osbrepositoryIdPut(id, oSBRepository, context, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to save a OSB Repository. The user_id (keycloak user id) will be automatically filled with the current user
         * @param {OSBRepository} oSBRepository The OSB repository to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osbrepositoryPost(oSBRepository: OSBRepository, options?: any): AxiosPromise<OSBRepository> {
            return localVarFp.osbrepositoryPost(oSBRepository, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to list all available tags.
         * @param {number} [page] The page number for starting to collect the result set.
         * @param {number} [perPage] The number of items to return.
         * @param {string} [q] The search string for filtering of the items to return. Format [field/relation[field]][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGet(page?: number, perPage?: number, q?: string, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.tagGet(page, perPage, q, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an tag from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagIdDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.tagIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to retrieve an tag from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagIdGet(id: number, options?: any): AxiosPromise<Tag> {
            return localVarFp.tagIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an tag in the repository.
         * @param {number} id 
         * @param {Tag} tag The tag to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagIdPut(id: number, tag: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.tagIdPut(id, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to save a Tag to the repository. The user_id (keycloak user id) will be automatically filled with the current user
         * @param {Tag} tag The Tag to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagPost(tag: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.tagPost(tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to list all available volumestorages.
         * @param {number} [page] The page number for starting to collect the result set.
         * @param {number} [perPage] The number of items to return.
         * @param {string} [q] The search string for filtering of the items to return. Format [field/relation[field]][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumestorageGet(page?: number, perPage?: number, q?: string, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.volumestorageGet(page, perPage, q, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an volumestorage from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumestorageIdDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.volumestorageIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to retrieve an volumestorage from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumestorageIdGet(id: number, options?: any): AxiosPromise<VolumeStorage> {
            return localVarFp.volumestorageIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an volumestorage in the repository.
         * @param {number} id 
         * @param {VolumeStorage} volumeStorage The volumestorage to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumestorageIdPut(id: number, volumeStorage: VolumeStorage, options?: any): AxiosPromise<VolumeStorage> {
            return localVarFp.volumestorageIdPut(id, volumeStorage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to save a VolumeStorage to the repository. The user_id (keycloak user id) will be automatically filled with the current user
         * @param {VolumeStorage} volumeStorage The VolumeStorage to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumestoragePost(volumeStorage: VolumeStorage, options?: any): AxiosPromise<VolumeStorage> {
            return localVarFp.volumestoragePost(volumeStorage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to list all available workspaces.
         * @param {number} [page] The page number for starting to collect the result set.
         * @param {number} [perPage] The number of items to return.
         * @param {string} [q] The search string for filtering of the items to return. Multiple criteria are seperated by \&#39;+\&#39; (and operator is applied). Format [field/relation[field]][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]
         * @param {string} [tags] The tags to filter with Multiple parameters are concatenated with + (OR operator)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceGet(page?: number, perPage?: number, q?: string, tags?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.workspaceGet(page, perPage, q, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a workspace from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceIdDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.workspaceIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to retrieve a workspace from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceIdGet(id: number, options?: any): AxiosPromise<Workspace> {
            return localVarFp.workspaceIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a workspace in the repository.
         * @param {number} id 
         * @param {Workspace} workspace The workspace to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceIdPut(id: number, workspace: Workspace, options?: any): AxiosPromise<Workspace> {
            return localVarFp.workspaceIdPut(id, workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to save a Workspace to the repository. The user_id (keycloak user id) will be automatically filled with the current user
         * @param {Workspace} workspace The Workspace to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacePost(workspace: Workspace, options?: any): AxiosPromise<Workspace> {
            return localVarFp.workspacePost(workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a WorkspaceResource.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceresourceIdDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.workspaceresourceIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to retrieve a WorkspaceResource.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceresourceIdGet(id: number, options?: any): AxiosPromise<WorkspaceResource> {
            return localVarFp.workspaceresourceIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the WorkspaceResource.
         * @param {number} id 
         * @param {WorkspaceResource} workspaceResource The WorkspaceResource to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceresourceIdPut(id: number, workspaceResource: WorkspaceResource, options?: any): AxiosPromise<WorkspaceResource> {
            return localVarFp.workspaceresourceIdPut(id, workspaceResource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to save a WorkspaceResource to the repository.
         * @param {WorkspaceResource} workspaceResource The WorkspaceResource to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceresourcePost(workspaceResource: WorkspaceResource, options?: any): AxiosPromise<WorkspaceResource> {
            return localVarFp.workspaceresourcePost(workspaceResource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds and image to the workspace.
         * @param {number} id Workspace ID of the workspace
         * @param {any} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesControllersWorkspaceControllerAddimage(id: number, image?: any, options?: any): AxiosPromise<void> {
            return localVarFp.workspacesControllersWorkspaceControllerAddimage(id, image, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Imports the ResourceOrigins into the Workspace and creates/updates the workspace resources
         * @param {number} id Workspace ID of the workspace
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesControllersWorkspaceControllerImportResources(id: number, inlineObject?: InlineObject, options?: any): AxiosPromise<void> {
            return localVarFp.workspacesControllersWorkspaceControllerImportResources(id, inlineObject, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sets the thumbnail of the workspace.
         * @param {number} id Workspace ID of the workspace
         * @param {any} [thumbNail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesControllersWorkspaceControllerSetthumbnail(id: number, thumbNail?: any, options?: any): AxiosPromise<void> {
            return localVarFp.workspacesControllersWorkspaceControllerSetthumbnail(id, thumbNail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Clones a workspace
         * @param {number} id Workspace ID of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesControllersWorkspaceControllerWorkspaceClone(id: number, options?: any): AxiosPromise<Workspace> {
            return localVarFp.workspacesControllersWorkspaceControllerWorkspaceClone(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to register a WorkspaceResource open action. The WorkspaceResource timestamp last open will be updated
         * @param {number} id WorkspaceResource ID of the WorkspaceResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesControllersWorkspaceResourceControllerOpen(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.workspacesControllersWorkspaceResourceControllerOpen(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RestApi - object-oriented interface
 * @export
 * @class RestApi
 * @extends {BaseAPI}
 */
export class RestApi extends BaseAPI {
    /**
     * 
     * @summary Delete a Workspace Image from the workspace.
     * @param {number} id Workspace ID of the workspace
     * @param {number} imageId Workspace Image Id to be deleted from the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public delimage(id: number, imageId: number, options?: any) {
        return RestApiFp(this.configuration).delimage(id, imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to retrieve description for a repository.
     * @param {string} uri 
     * @param {RepositoryType} repositoryType 
     * @param {string} context 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public getDescription(uri: string, repositoryType: RepositoryType, context: string, options?: any) {
        return RestApiFp(this.configuration).getDescription(uri, repositoryType, context, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to retrieve a list of contexts of a repository.
     * @param {string} uri 
     * @param {RepositoryType} repositoryType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public getInfo(uri: string, repositoryType: RepositoryType, options?: any) {
        return RestApiFp(this.configuration).getInfo(uri, repositoryType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to list all available repositories.
     * @param {number} [page] The page number for starting to collect the result set.
     * @param {number} [perPage] The number of items to return.
     * @param {string} [q] The search string for filtering of the items to return. Format [field/relation[field]][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]. Multiple parameters are concatenated with + (OR operator)
     * @param {string} [tags] The tags to filter with Multiple parameters are concatenated with + (OR operator)
     * @param {string} [types] The tags to filter with Multiple parameters are concatenated with + (OR operator)
     * @param {string} [userId] The id of the owner user to filter with
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public osbrepositoryGet(page?: number, perPage?: number, q?: string, tags?: string, types?: string, userId?: string, options?: any) {
        return RestApiFp(this.configuration).osbrepositoryGet(page, perPage, q, tags, types, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a OSBRepository.
     * @param {number} id 
     * @param {string} [context] the context for getting the resources, optional
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public osbrepositoryIdDelete(id: number, context?: string, options?: any) {
        return RestApiFp(this.configuration).osbrepositoryIdDelete(id, context, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to retrieve a repository.
     * @param {number} id 
     * @param {string} [context] the context for getting the resources, optional
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public osbrepositoryIdGet(id: number, context?: string, options?: any) {
        return RestApiFp(this.configuration).osbrepositoryIdGet(id, context, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a OSB repository.
     * @param {number} id 
     * @param {OSBRepository} oSBRepository The repository to save.
     * @param {string} [context] the context for getting the resources, optional
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public osbrepositoryIdPut(id: number, oSBRepository: OSBRepository, context?: string, options?: any) {
        return RestApiFp(this.configuration).osbrepositoryIdPut(id, oSBRepository, context, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to save a OSB Repository. The user_id (keycloak user id) will be automatically filled with the current user
     * @param {OSBRepository} oSBRepository The OSB repository to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public osbrepositoryPost(oSBRepository: OSBRepository, options?: any) {
        return RestApiFp(this.configuration).osbrepositoryPost(oSBRepository, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to list all available tags.
     * @param {number} [page] The page number for starting to collect the result set.
     * @param {number} [perPage] The number of items to return.
     * @param {string} [q] The search string for filtering of the items to return. Format [field/relation[field]][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public tagGet(page?: number, perPage?: number, q?: string, options?: any) {
        return RestApiFp(this.configuration).tagGet(page, perPage, q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an tag from the repository.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public tagIdDelete(id: number, options?: any) {
        return RestApiFp(this.configuration).tagIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to retrieve an tag from the repository.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public tagIdGet(id: number, options?: any) {
        return RestApiFp(this.configuration).tagIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an tag in the repository.
     * @param {number} id 
     * @param {Tag} tag The tag to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public tagIdPut(id: number, tag: Tag, options?: any) {
        return RestApiFp(this.configuration).tagIdPut(id, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to save a Tag to the repository. The user_id (keycloak user id) will be automatically filled with the current user
     * @param {Tag} tag The Tag to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public tagPost(tag: Tag, options?: any) {
        return RestApiFp(this.configuration).tagPost(tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to list all available volumestorages.
     * @param {number} [page] The page number for starting to collect the result set.
     * @param {number} [perPage] The number of items to return.
     * @param {string} [q] The search string for filtering of the items to return. Format [field/relation[field]][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public volumestorageGet(page?: number, perPage?: number, q?: string, options?: any) {
        return RestApiFp(this.configuration).volumestorageGet(page, perPage, q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an volumestorage from the repository.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public volumestorageIdDelete(id: number, options?: any) {
        return RestApiFp(this.configuration).volumestorageIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to retrieve an volumestorage from the repository.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public volumestorageIdGet(id: number, options?: any) {
        return RestApiFp(this.configuration).volumestorageIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an volumestorage in the repository.
     * @param {number} id 
     * @param {VolumeStorage} volumeStorage The volumestorage to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public volumestorageIdPut(id: number, volumeStorage: VolumeStorage, options?: any) {
        return RestApiFp(this.configuration).volumestorageIdPut(id, volumeStorage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to save a VolumeStorage to the repository. The user_id (keycloak user id) will be automatically filled with the current user
     * @param {VolumeStorage} volumeStorage The VolumeStorage to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public volumestoragePost(volumeStorage: VolumeStorage, options?: any) {
        return RestApiFp(this.configuration).volumestoragePost(volumeStorage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to list all available workspaces.
     * @param {number} [page] The page number for starting to collect the result set.
     * @param {number} [perPage] The number of items to return.
     * @param {string} [q] The search string for filtering of the items to return. Multiple criteria are seperated by \&#39;+\&#39; (and operator is applied). Format [field/relation[field]][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]
     * @param {string} [tags] The tags to filter with Multiple parameters are concatenated with + (OR operator)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public workspaceGet(page?: number, perPage?: number, q?: string, tags?: string, options?: any) {
        return RestApiFp(this.configuration).workspaceGet(page, perPage, q, tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a workspace from the repository.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public workspaceIdDelete(id: number, options?: any) {
        return RestApiFp(this.configuration).workspaceIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to retrieve a workspace from the repository.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public workspaceIdGet(id: number, options?: any) {
        return RestApiFp(this.configuration).workspaceIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a workspace in the repository.
     * @param {number} id 
     * @param {Workspace} workspace The workspace to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public workspaceIdPut(id: number, workspace: Workspace, options?: any) {
        return RestApiFp(this.configuration).workspaceIdPut(id, workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to save a Workspace to the repository. The user_id (keycloak user id) will be automatically filled with the current user
     * @param {Workspace} workspace The Workspace to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public workspacePost(workspace: Workspace, options?: any) {
        return RestApiFp(this.configuration).workspacePost(workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a WorkspaceResource.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public workspaceresourceIdDelete(id: number, options?: any) {
        return RestApiFp(this.configuration).workspaceresourceIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to retrieve a WorkspaceResource.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public workspaceresourceIdGet(id: number, options?: any) {
        return RestApiFp(this.configuration).workspaceresourceIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the WorkspaceResource.
     * @param {number} id 
     * @param {WorkspaceResource} workspaceResource The WorkspaceResource to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public workspaceresourceIdPut(id: number, workspaceResource: WorkspaceResource, options?: any) {
        return RestApiFp(this.configuration).workspaceresourceIdPut(id, workspaceResource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to save a WorkspaceResource to the repository.
     * @param {WorkspaceResource} workspaceResource The WorkspaceResource to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public workspaceresourcePost(workspaceResource: WorkspaceResource, options?: any) {
        return RestApiFp(this.configuration).workspaceresourcePost(workspaceResource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds and image to the workspace.
     * @param {number} id Workspace ID of the workspace
     * @param {any} [image] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public workspacesControllersWorkspaceControllerAddimage(id: number, image?: any, options?: any) {
        return RestApiFp(this.configuration).workspacesControllersWorkspaceControllerAddimage(id, image, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Imports the ResourceOrigins into the Workspace and creates/updates the workspace resources
     * @param {number} id Workspace ID of the workspace
     * @param {InlineObject} [inlineObject] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public workspacesControllersWorkspaceControllerImportResources(id: number, inlineObject?: InlineObject, options?: any) {
        return RestApiFp(this.configuration).workspacesControllersWorkspaceControllerImportResources(id, inlineObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sets the thumbnail of the workspace.
     * @param {number} id Workspace ID of the workspace
     * @param {any} [thumbNail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public workspacesControllersWorkspaceControllerSetthumbnail(id: number, thumbNail?: any, options?: any) {
        return RestApiFp(this.configuration).workspacesControllersWorkspaceControllerSetthumbnail(id, thumbNail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Clones a workspace
     * @param {number} id Workspace ID of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public workspacesControllersWorkspaceControllerWorkspaceClone(id: number, options?: any) {
        return RestApiFp(this.configuration).workspacesControllersWorkspaceControllerWorkspaceClone(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to register a WorkspaceResource open action. The WorkspaceResource timestamp last open will be updated
     * @param {number} id WorkspaceResource ID of the WorkspaceResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public workspacesControllersWorkspaceResourceControllerOpen(id: number, options?: any) {
        return RestApiFp(this.configuration).workspacesControllersWorkspaceResourceControllerOpen(id, options).then((request) => request(this.axios, this.basePath));
    }
}


