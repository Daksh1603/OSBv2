/* tslint:disable */
/* eslint-disable */
/**
 * Workspaces manager API
 * Opensource Brain Platform - Reference Workspaces manager API
 *
 * The version of the OpenAPI document: 0.2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    FigshareRepository,
    FigshareRepositoryFromJSON,
    FigshareRepositoryToJSON,
    GITRepository,
    GITRepositoryFromJSON,
    GITRepositoryToJSON,
    InlineObject2,
    InlineObject2FromJSON,
    InlineObject2ToJSON,
    InlineResponse200,
    InlineResponse200FromJSON,
    InlineResponse200ToJSON,
    InlineResponse2001,
    InlineResponse2001FromJSON,
    InlineResponse2001ToJSON,
    InlineResponse2002,
    InlineResponse2002FromJSON,
    InlineResponse2002ToJSON,
    InlineResponse2003,
    InlineResponse2003FromJSON,
    InlineResponse2003ToJSON,
    OSBRepository,
    OSBRepositoryFromJSON,
    OSBRepositoryToJSON,
    RepositoryResource,
    RepositoryResourceFromJSON,
    RepositoryResourceToJSON,
    RepositoryType,
    RepositoryTypeFromJSON,
    RepositoryTypeToJSON,
    VolumeStorage,
    VolumeStorageFromJSON,
    VolumeStorageToJSON,
    Workspace,
    WorkspaceFromJSON,
    WorkspaceToJSON,
    WorkspaceResource,
    WorkspaceResourceFromJSON,
    WorkspaceResourceToJSON,
} from '../models';

export interface FigsharerepositoryGetRequest {
    page?: number;
    perPage?: number;
    q?: string;
}

export interface FigsharerepositoryIdDeleteRequest {
    id: number;
}

export interface FigsharerepositoryIdGetRequest {
    id: number;
}

export interface FigsharerepositoryIdPutRequest {
    id: number;
    figshareRepository: FigshareRepository;
}

export interface FigsharerepositoryPostRequest {
    figshareRepository: FigshareRepository;
}

export interface GitrepositoryIdDeleteRequest {
    id: number;
}

export interface GitrepositoryIdGetRequest {
    id: number;
}

export interface GitrepositoryIdPutRequest {
    id: number;
    gITRepository: GITRepository;
}

export interface GitrepositoryPostRequest {
    gITRepository: GITRepository;
}

export interface OsbrepositoryGetRequest {
    page?: number;
    perPage?: number;
    q?: string;
}

export interface OsbrepositoryresourceIdDeleteRequest {
    id: number;
    repositoryResource: RepositoryResource;
}

export interface PostRequest {
    inlineObject2: InlineObject2;
}

export interface VolumestorageGetRequest {
    page?: number;
    perPage?: number;
    q?: string;
}

export interface VolumestorageIdDeleteRequest {
    id: number;
}

export interface VolumestorageIdGetRequest {
    id: number;
}

export interface VolumestorageIdPutRequest {
    id: number;
    volumeStorage: VolumeStorage;
}

export interface VolumestoragePostRequest {
    volumeStorage: VolumeStorage;
}

export interface WorkspaceGetRequest {
    page?: number;
    perPage?: number;
    q?: string;
}

export interface WorkspaceIdDeleteRequest {
    id: number;
}

export interface WorkspaceIdGetRequest {
    id: number;
}

export interface WorkspaceIdPutRequest {
    id: number;
    workspace: Workspace;
}

export interface WorkspacePostRequest {
    workspace: Workspace;
}

export interface WorkspaceresourceIdDeleteRequest {
    id: number;
}

export interface WorkspaceresourceIdGetRequest {
    id: number;
}

export interface WorkspaceresourceIdPutRequest {
    id: number;
    workspaceResource: WorkspaceResource;
}

export interface WorkspaceresourcePostRequest {
    workspaceResource: WorkspaceResource;
}

export interface WorkspacesControllersOsbrepositoryControllerGetRequest {
    id: number;
    context?: string;
}

export interface WorkspacesControllersOsbrepositoryControllerGetContextsRequest {
    uri: string;
    repositoryType: RepositoryType;
}

/**
 * 
 */
export class RestApi extends runtime.BaseAPI {

    /**
     * Used to list all available figsharerepositories.
     */
    async figsharerepositoryGetRaw(requestParameters: FigsharerepositoryGetRequest): Promise<runtime.ApiResponse<InlineResponse2002>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.perPage !== undefined) {
            queryParameters['per_page'] = requestParameters.perPage;
        }

        if (requestParameters.q !== undefined) {
            queryParameters['q'] = requestParameters.q;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/figsharerepository`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2002FromJSON(jsonValue));
    }

    /**
     * Used to list all available figsharerepositories.
     */
    async figsharerepositoryGet(requestParameters: FigsharerepositoryGetRequest): Promise<InlineResponse2002> {
        const response = await this.figsharerepositoryGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Delete an figsharerepository from the repository.
     */
    async figsharerepositoryIdDeleteRaw(requestParameters: FigsharerepositoryIdDeleteRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling figsharerepositoryIdDelete.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("bearerAuth", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/figsharerepository/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete an figsharerepository from the repository.
     */
    async figsharerepositoryIdDelete(requestParameters: FigsharerepositoryIdDeleteRequest): Promise<void> {
        await this.figsharerepositoryIdDeleteRaw(requestParameters);
    }

    /**
     * Used to retrieve an figsharerepository from the repository.
     */
    async figsharerepositoryIdGetRaw(requestParameters: FigsharerepositoryIdGetRequest): Promise<runtime.ApiResponse<FigshareRepository>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling figsharerepositoryIdGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/figsharerepository/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => FigshareRepositoryFromJSON(jsonValue));
    }

    /**
     * Used to retrieve an figsharerepository from the repository.
     */
    async figsharerepositoryIdGet(requestParameters: FigsharerepositoryIdGetRequest): Promise<FigshareRepository> {
        const response = await this.figsharerepositoryIdGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update an figsharerepository in the repository.
     */
    async figsharerepositoryIdPutRaw(requestParameters: FigsharerepositoryIdPutRequest): Promise<runtime.ApiResponse<FigshareRepository>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling figsharerepositoryIdPut.');
        }

        if (requestParameters.figshareRepository === null || requestParameters.figshareRepository === undefined) {
            throw new runtime.RequiredError('figshareRepository','Required parameter requestParameters.figshareRepository was null or undefined when calling figsharerepositoryIdPut.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("bearerAuth", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/figsharerepository/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: FigshareRepositoryToJSON(requestParameters.figshareRepository),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => FigshareRepositoryFromJSON(jsonValue));
    }

    /**
     * Update an figsharerepository in the repository.
     */
    async figsharerepositoryIdPut(requestParameters: FigsharerepositoryIdPutRequest): Promise<FigshareRepository> {
        const response = await this.figsharerepositoryIdPutRaw(requestParameters);
        return await response.value();
    }

    /**
     * Used to save a FigshareRepository to the repository. The user_id (keycloak user id) will be automatically filled with the current user
     */
    async figsharerepositoryPostRaw(requestParameters: FigsharerepositoryPostRequest): Promise<runtime.ApiResponse<FigshareRepository>> {
        if (requestParameters.figshareRepository === null || requestParameters.figshareRepository === undefined) {
            throw new runtime.RequiredError('figshareRepository','Required parameter requestParameters.figshareRepository was null or undefined when calling figsharerepositoryPost.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("bearerAuth", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/figsharerepository`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FigshareRepositoryToJSON(requestParameters.figshareRepository),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => FigshareRepositoryFromJSON(jsonValue));
    }

    /**
     * Used to save a FigshareRepository to the repository. The user_id (keycloak user id) will be automatically filled with the current user
     */
    async figsharerepositoryPost(requestParameters: FigsharerepositoryPostRequest): Promise<FigshareRepository> {
        const response = await this.figsharerepositoryPostRaw(requestParameters);
        return await response.value();
    }

    /**
     * Delete a gitrepository from the repository.
     */
    async gitrepositoryIdDeleteRaw(requestParameters: GitrepositoryIdDeleteRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling gitrepositoryIdDelete.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("bearerAuth", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/gitrepository/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a gitrepository from the repository.
     */
    async gitrepositoryIdDelete(requestParameters: GitrepositoryIdDeleteRequest): Promise<void> {
        await this.gitrepositoryIdDeleteRaw(requestParameters);
    }

    /**
     * Used to retrieve a gitrepository from the repository.
     */
    async gitrepositoryIdGetRaw(requestParameters: GitrepositoryIdGetRequest): Promise<runtime.ApiResponse<GITRepository>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling gitrepositoryIdGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/gitrepository/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => GITRepositoryFromJSON(jsonValue));
    }

    /**
     * Used to retrieve a gitrepository from the repository.
     */
    async gitrepositoryIdGet(requestParameters: GitrepositoryIdGetRequest): Promise<GITRepository> {
        const response = await this.gitrepositoryIdGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update a gitrepository in the repository.
     */
    async gitrepositoryIdPutRaw(requestParameters: GitrepositoryIdPutRequest): Promise<runtime.ApiResponse<GITRepository>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling gitrepositoryIdPut.');
        }

        if (requestParameters.gITRepository === null || requestParameters.gITRepository === undefined) {
            throw new runtime.RequiredError('gITRepository','Required parameter requestParameters.gITRepository was null or undefined when calling gitrepositoryIdPut.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("bearerAuth", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/gitrepository/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: GITRepositoryToJSON(requestParameters.gITRepository),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => GITRepositoryFromJSON(jsonValue));
    }

    /**
     * Update a gitrepository in the repository.
     */
    async gitrepositoryIdPut(requestParameters: GitrepositoryIdPutRequest): Promise<GITRepository> {
        const response = await this.gitrepositoryIdPutRaw(requestParameters);
        return await response.value();
    }

    /**
     * Used to save a GITRepository to the repository. The user_id (keycloak user id) will be automatically filled with the current user
     */
    async gitrepositoryPostRaw(requestParameters: GitrepositoryPostRequest): Promise<runtime.ApiResponse<GITRepository>> {
        if (requestParameters.gITRepository === null || requestParameters.gITRepository === undefined) {
            throw new runtime.RequiredError('gITRepository','Required parameter requestParameters.gITRepository was null or undefined when calling gitrepositoryPost.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/gitrepository`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GITRepositoryToJSON(requestParameters.gITRepository),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => GITRepositoryFromJSON(jsonValue));
    }

    /**
     * Used to save a GITRepository to the repository. The user_id (keycloak user id) will be automatically filled with the current user
     */
    async gitrepositoryPost(requestParameters: GitrepositoryPostRequest): Promise<GITRepository> {
        const response = await this.gitrepositoryPostRaw(requestParameters);
        return await response.value();
    }

    /**
     * Used to list all available repositories.
     */
    async osbrepositoryGetRaw(requestParameters: OsbrepositoryGetRequest): Promise<runtime.ApiResponse<InlineResponse2001>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.perPage !== undefined) {
            queryParameters['per_page'] = requestParameters.perPage;
        }

        if (requestParameters.q !== undefined) {
            queryParameters['q'] = requestParameters.q;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/osbrepository`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2001FromJSON(jsonValue));
    }

    /**
     * Used to list all available repositories.
     */
    async osbrepositoryGet(requestParameters: OsbrepositoryGetRequest): Promise<InlineResponse2001> {
        const response = await this.osbrepositoryGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Delete a resource from a context of the osb repository.
     */
    async osbrepositoryresourceIdDeleteRaw(requestParameters: OsbrepositoryresourceIdDeleteRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling osbrepositoryresourceIdDelete.');
        }

        if (requestParameters.repositoryResource === null || requestParameters.repositoryResource === undefined) {
            throw new runtime.RequiredError('repositoryResource','Required parameter requestParameters.repositoryResource was null or undefined when calling osbrepositoryresourceIdDelete.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/osbrepositoryresource/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: RepositoryResourceToJSON(requestParameters.repositoryResource),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a resource from a context of the osb repository.
     */
    async osbrepositoryresourceIdDelete(requestParameters: OsbrepositoryresourceIdDeleteRequest): Promise<void> {
        await this.osbrepositoryresourceIdDeleteRaw(requestParameters);
    }

    /**
     * Used to save a resource to a context of the osb repository.
     */
    async postRaw(requestParameters: PostRequest): Promise<runtime.ApiResponse<RepositoryResource>> {
        if (requestParameters.inlineObject2 === null || requestParameters.inlineObject2 === undefined) {
            throw new runtime.RequiredError('inlineObject2','Required parameter requestParameters.inlineObject2 was null or undefined when calling post.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/osbrepositoryresource`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: InlineObject2ToJSON(requestParameters.inlineObject2),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RepositoryResourceFromJSON(jsonValue));
    }

    /**
     * Used to save a resource to a context of the osb repository.
     */
    async post(requestParameters: PostRequest): Promise<RepositoryResource> {
        const response = await this.postRaw(requestParameters);
        return await response.value();
    }

    /**
     * Used to list all available volumestorages.
     */
    async volumestorageGetRaw(requestParameters: VolumestorageGetRequest): Promise<runtime.ApiResponse<InlineResponse2003>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.perPage !== undefined) {
            queryParameters['per_page'] = requestParameters.perPage;
        }

        if (requestParameters.q !== undefined) {
            queryParameters['q'] = requestParameters.q;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("bearerAuth", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/volumestorage`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2003FromJSON(jsonValue));
    }

    /**
     * Used to list all available volumestorages.
     */
    async volumestorageGet(requestParameters: VolumestorageGetRequest): Promise<InlineResponse2003> {
        const response = await this.volumestorageGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Delete an volumestorage from the repository.
     */
    async volumestorageIdDeleteRaw(requestParameters: VolumestorageIdDeleteRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling volumestorageIdDelete.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("bearerAuth", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/volumestorage/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete an volumestorage from the repository.
     */
    async volumestorageIdDelete(requestParameters: VolumestorageIdDeleteRequest): Promise<void> {
        await this.volumestorageIdDeleteRaw(requestParameters);
    }

    /**
     * Used to retrieve an volumestorage from the repository.
     */
    async volumestorageIdGetRaw(requestParameters: VolumestorageIdGetRequest): Promise<runtime.ApiResponse<VolumeStorage>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling volumestorageIdGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/volumestorage/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => VolumeStorageFromJSON(jsonValue));
    }

    /**
     * Used to retrieve an volumestorage from the repository.
     */
    async volumestorageIdGet(requestParameters: VolumestorageIdGetRequest): Promise<VolumeStorage> {
        const response = await this.volumestorageIdGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update an volumestorage in the repository.
     */
    async volumestorageIdPutRaw(requestParameters: VolumestorageIdPutRequest): Promise<runtime.ApiResponse<VolumeStorage>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling volumestorageIdPut.');
        }

        if (requestParameters.volumeStorage === null || requestParameters.volumeStorage === undefined) {
            throw new runtime.RequiredError('volumeStorage','Required parameter requestParameters.volumeStorage was null or undefined when calling volumestorageIdPut.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("bearerAuth", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/volumestorage/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: VolumeStorageToJSON(requestParameters.volumeStorage),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => VolumeStorageFromJSON(jsonValue));
    }

    /**
     * Update an volumestorage in the repository.
     */
    async volumestorageIdPut(requestParameters: VolumestorageIdPutRequest): Promise<VolumeStorage> {
        const response = await this.volumestorageIdPutRaw(requestParameters);
        return await response.value();
    }

    /**
     * Used to save a VolumeStorage to the repository. The user_id (keycloak user id) will be automatically filled with the current user
     */
    async volumestoragePostRaw(requestParameters: VolumestoragePostRequest): Promise<runtime.ApiResponse<VolumeStorage>> {
        if (requestParameters.volumeStorage === null || requestParameters.volumeStorage === undefined) {
            throw new runtime.RequiredError('volumeStorage','Required parameter requestParameters.volumeStorage was null or undefined when calling volumestoragePost.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("bearerAuth", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/volumestorage`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: VolumeStorageToJSON(requestParameters.volumeStorage),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => VolumeStorageFromJSON(jsonValue));
    }

    /**
     * Used to save a VolumeStorage to the repository. The user_id (keycloak user id) will be automatically filled with the current user
     */
    async volumestoragePost(requestParameters: VolumestoragePostRequest): Promise<VolumeStorage> {
        const response = await this.volumestoragePostRaw(requestParameters);
        return await response.value();
    }

    /**
     * Used to list all available workspaces.
     */
    async workspaceGetRaw(requestParameters: WorkspaceGetRequest): Promise<runtime.ApiResponse<InlineResponse200>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.perPage !== undefined) {
            queryParameters['per_page'] = requestParameters.perPage;
        }

        if (requestParameters.q !== undefined) {
            queryParameters['q'] = requestParameters.q;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse200FromJSON(jsonValue));
    }

    /**
     * Used to list all available workspaces.
     */
    async workspaceGet(requestParameters: WorkspaceGetRequest): Promise<InlineResponse200> {
        const response = await this.workspaceGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Delete a workspace from the repository.
     */
    async workspaceIdDeleteRaw(requestParameters: WorkspaceIdDeleteRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdDelete.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("bearerAuth", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/workspace/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a workspace from the repository.
     */
    async workspaceIdDelete(requestParameters: WorkspaceIdDeleteRequest): Promise<void> {
        await this.workspaceIdDeleteRaw(requestParameters);
    }

    /**
     * Used to retrieve a workspace from the repository.
     */
    async workspaceIdGetRaw(requestParameters: WorkspaceIdGetRequest): Promise<runtime.ApiResponse<Workspace>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceFromJSON(jsonValue));
    }

    /**
     * Used to retrieve a workspace from the repository.
     */
    async workspaceIdGet(requestParameters: WorkspaceIdGetRequest): Promise<Workspace> {
        const response = await this.workspaceIdGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update a workspace in the repository.
     */
    async workspaceIdPutRaw(requestParameters: WorkspaceIdPutRequest): Promise<runtime.ApiResponse<Workspace>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdPut.');
        }

        if (requestParameters.workspace === null || requestParameters.workspace === undefined) {
            throw new runtime.RequiredError('workspace','Required parameter requestParameters.workspace was null or undefined when calling workspaceIdPut.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("bearerAuth", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/workspace/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: WorkspaceToJSON(requestParameters.workspace),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceFromJSON(jsonValue));
    }

    /**
     * Update a workspace in the repository.
     */
    async workspaceIdPut(requestParameters: WorkspaceIdPutRequest): Promise<Workspace> {
        const response = await this.workspaceIdPutRaw(requestParameters);
        return await response.value();
    }

    /**
     * Used to save a Workspace to the repository. The user_id (keycloak user id) will be automatically filled with the current user
     */
    async workspacePostRaw(requestParameters: WorkspacePostRequest): Promise<runtime.ApiResponse<Workspace>> {
        if (requestParameters.workspace === null || requestParameters.workspace === undefined) {
            throw new runtime.RequiredError('workspace','Required parameter requestParameters.workspace was null or undefined when calling workspacePost.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("bearerAuth", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/workspace`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WorkspaceToJSON(requestParameters.workspace),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceFromJSON(jsonValue));
    }

    /**
     * Used to save a Workspace to the repository. The user_id (keycloak user id) will be automatically filled with the current user
     */
    async workspacePost(requestParameters: WorkspacePostRequest): Promise<Workspace> {
        const response = await this.workspacePostRaw(requestParameters);
        return await response.value();
    }

    /**
     * Delete a WorkspaceResource.
     */
    async workspaceresourceIdDeleteRaw(requestParameters: WorkspaceresourceIdDeleteRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceresourceIdDelete.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("bearerAuth", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/workspaceresource/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a WorkspaceResource.
     */
    async workspaceresourceIdDelete(requestParameters: WorkspaceresourceIdDeleteRequest): Promise<void> {
        await this.workspaceresourceIdDeleteRaw(requestParameters);
    }

    /**
     * Used to retrieve a WorkspaceResource.
     */
    async workspaceresourceIdGetRaw(requestParameters: WorkspaceresourceIdGetRequest): Promise<runtime.ApiResponse<WorkspaceResource>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceresourceIdGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("bearerAuth", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/workspaceresource/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceResourceFromJSON(jsonValue));
    }

    /**
     * Used to retrieve a WorkspaceResource.
     */
    async workspaceresourceIdGet(requestParameters: WorkspaceresourceIdGetRequest): Promise<WorkspaceResource> {
        const response = await this.workspaceresourceIdGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update the WorkspaceResource.
     */
    async workspaceresourceIdPutRaw(requestParameters: WorkspaceresourceIdPutRequest): Promise<runtime.ApiResponse<WorkspaceResource>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceresourceIdPut.');
        }

        if (requestParameters.workspaceResource === null || requestParameters.workspaceResource === undefined) {
            throw new runtime.RequiredError('workspaceResource','Required parameter requestParameters.workspaceResource was null or undefined when calling workspaceresourceIdPut.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("bearerAuth", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/workspaceresource/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: WorkspaceResourceToJSON(requestParameters.workspaceResource),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceResourceFromJSON(jsonValue));
    }

    /**
     * Update the WorkspaceResource.
     */
    async workspaceresourceIdPut(requestParameters: WorkspaceresourceIdPutRequest): Promise<WorkspaceResource> {
        const response = await this.workspaceresourceIdPutRaw(requestParameters);
        return await response.value();
    }

    /**
     * Used to save a WorkspaceResource to the repository.
     */
    async workspaceresourcePostRaw(requestParameters: WorkspaceresourcePostRequest): Promise<runtime.ApiResponse<WorkspaceResource>> {
        if (requestParameters.workspaceResource === null || requestParameters.workspaceResource === undefined) {
            throw new runtime.RequiredError('workspaceResource','Required parameter requestParameters.workspaceResource was null or undefined when calling workspaceresourcePost.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("bearerAuth", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/workspaceresource`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WorkspaceResourceToJSON(requestParameters.workspaceResource),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceResourceFromJSON(jsonValue));
    }

    /**
     * Used to save a WorkspaceResource to the repository.
     */
    async workspaceresourcePost(requestParameters: WorkspaceresourcePostRequest): Promise<WorkspaceResource> {
        const response = await this.workspaceresourcePostRaw(requestParameters);
        return await response.value();
    }

    /**
     * Used to retrieve a repository.
     */
    async workspacesControllersOsbrepositoryControllerGetRaw(requestParameters: WorkspacesControllersOsbrepositoryControllerGetRequest): Promise<runtime.ApiResponse<OSBRepository>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspacesControllersOsbrepositoryControllerGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.context !== undefined) {
            queryParameters['context'] = requestParameters.context;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/osbrepository/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OSBRepositoryFromJSON(jsonValue));
    }

    /**
     * Used to retrieve a repository.
     */
    async workspacesControllersOsbrepositoryControllerGet(requestParameters: WorkspacesControllersOsbrepositoryControllerGetRequest): Promise<OSBRepository> {
        const response = await this.workspacesControllersOsbrepositoryControllerGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Used to retrieve the contexts of a repository.
     */
    async workspacesControllersOsbrepositoryControllerGetContextsRaw(requestParameters: WorkspacesControllersOsbrepositoryControllerGetContextsRequest): Promise<runtime.ApiResponse<OSBRepository>> {
        if (requestParameters.uri === null || requestParameters.uri === undefined) {
            throw new runtime.RequiredError('uri','Required parameter requestParameters.uri was null or undefined when calling workspacesControllersOsbrepositoryControllerGetContexts.');
        }

        if (requestParameters.repositoryType === null || requestParameters.repositoryType === undefined) {
            throw new runtime.RequiredError('repositoryType','Required parameter requestParameters.repositoryType was null or undefined when calling workspacesControllersOsbrepositoryControllerGetContexts.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.uri !== undefined) {
            queryParameters['uri'] = requestParameters.uri;
        }

        if (requestParameters.repositoryType !== undefined) {
            queryParameters['repository_type'] = requestParameters.repositoryType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/osbrepository/context`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OSBRepositoryFromJSON(jsonValue));
    }

    /**
     * Used to retrieve the contexts of a repository.
     */
    async workspacesControllersOsbrepositoryControllerGetContexts(requestParameters: WorkspacesControllersOsbrepositoryControllerGetContextsRequest): Promise<OSBRepository> {
        const response = await this.workspacesControllersOsbrepositoryControllerGetContextsRaw(requestParameters);
        return await response.value();
    }

}
