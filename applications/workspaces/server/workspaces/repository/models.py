"""Autogenerated SQLAlchemy models based on OpenAlchemy models."""
# pylint: disable=no-member,super-init-not-called,unused-argument

import datetime
import typing

import sqlalchemy
import typing_extensions
from sqlalchemy import orm

from open_alchemy import models


class _WorkspaceDictBase(typing_extensions.TypedDict, total=True):
    """TypedDict for properties that are required."""

    name: str
    description: str


class WorkspaceDict(_WorkspaceDictBase, total=False):
    """TypedDict for properties that are not required."""

    id: int
    timestamp_created: typing.Optional[datetime.datetime]
    timestamp_updated: typing.Optional[datetime.datetime]
    tags: typing.Sequence["WorkspaceTagDict"]
    last_opened_resource_id: typing.Optional[int]
    thumbnail: typing.Optional[str]
    gallery: typing.Sequence["WorkspaceImageDict"]
    user_id: typing.Optional[str]
    publicable: bool
    license: typing.Optional[str]
    collaborators: typing.Sequence["WorkspaceCollaboratorDict"]
    resources: typing.Sequence["WorkspaceResourceDict"]
    storage: typing.Optional["VolumeStorageDict"]


class TWorkspace(typing_extensions.Protocol):
    """
    SQLAlchemy model protocol.

    Workspace item

    Attrs:
        id: The id of the Workspace.
        name: Workspace name.
        description: Workspace description.
        timestamp_created: Date/time the Workspace is created
        timestamp_updated: Date/time the Workspace is last updated
        tags: Workspace tags
        last_opened_resource_id: The workspace resource id the workspace is
            opened last with
        thumbnail: The thumbnail of the Workspace.
        gallery: Gallery with images of the workspace
        user_id: Workspace keycloak user id, will be automatically be set to
            the logged in user
        publicable: Is the workspace available for non collaborators? Default
            false
        license: Workspace license
        collaborators: Collaborators who work on the workspace
        resources: Resources of the workspace
        storage: The storage of the Workspace.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: int
    name: str
    description: str
    timestamp_created: typing.Optional[datetime.datetime]
    timestamp_updated: typing.Optional[datetime.datetime]
    tags: typing.Sequence["TWorkspaceTag"]
    last_opened_resource_id: typing.Optional[int]
    thumbnail: typing.Optional[str]
    gallery: typing.Sequence["TWorkspaceImage"]
    user_id: typing.Optional[str]
    publicable: bool
    license: typing.Optional[str]
    collaborators: typing.Sequence["TWorkspaceCollaborator"]
    resources: typing.Sequence["TWorkspaceResource"]
    storage: typing.Optional["TVolumeStorage"]

    def __init__(
        self,
        name: str,
        description: str,
        id: typing.Optional[int] = None,
        timestamp_created: typing.Optional[datetime.datetime] = None,
        timestamp_updated: typing.Optional[datetime.datetime] = None,
        tags: typing.Optional[typing.Sequence["TWorkspaceTag"]] = None,
        last_opened_resource_id: typing.Optional[int] = None,
        thumbnail: typing.Optional[str] = None,
        gallery: typing.Optional[typing.Sequence["TWorkspaceImage"]] = None,
        user_id: typing.Optional[str] = None,
        publicable: bool = False,
        license: typing.Optional[str] = None,
        collaborators: typing.Optional[
            typing.Sequence["TWorkspaceCollaborator"]
        ] = None,
        resources: typing.Optional[typing.Sequence["TWorkspaceResource"]] = None,
        storage: typing.Optional["TVolumeStorage"] = None,
    ) -> None:
        """
        Construct.

        Args:
            id: The id of the Workspace.
            name: Workspace name.
            description: Workspace description.
            timestamp_created: Date/time the Workspace is created
            timestamp_updated: Date/time the Workspace is last updated
            tags: Workspace tags
            last_opened_resource_id: The workspace resource id the workspace is
                opened last with
            thumbnail: The thumbnail of the Workspace.
            gallery: Gallery with images of the workspace
            user_id: Workspace keycloak user id, will be automatically be set
                to the logged in user
            publicable: Is the workspace available for non collaborators?
                Default false
            license: Workspace license
            collaborators: Collaborators who work on the workspace
            resources: Resources of the workspace
            storage: The storage of the Workspace.

        """
        ...

    @classmethod
    def from_dict(
        cls,
        name: str,
        description: str,
        id: typing.Optional[int] = None,
        timestamp_created: typing.Optional[datetime.datetime] = None,
        timestamp_updated: typing.Optional[datetime.datetime] = None,
        tags: typing.Optional[typing.Sequence["WorkspaceTagDict"]] = None,
        last_opened_resource_id: typing.Optional[int] = None,
        thumbnail: typing.Optional[str] = None,
        gallery: typing.Optional[typing.Sequence["WorkspaceImageDict"]] = None,
        user_id: typing.Optional[str] = None,
        publicable: bool = False,
        license: typing.Optional[str] = None,
        collaborators: typing.Optional[
            typing.Sequence["WorkspaceCollaboratorDict"]
        ] = None,
        resources: typing.Optional[typing.Sequence["WorkspaceResourceDict"]] = None,
        storage: typing.Optional["VolumeStorageDict"] = None,
    ) -> "TWorkspace":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the Workspace.
            name: Workspace name.
            description: Workspace description.
            timestamp_created: Date/time the Workspace is created
            timestamp_updated: Date/time the Workspace is last updated
            tags: Workspace tags
            last_opened_resource_id: The workspace resource id the workspace is
                opened last with
            thumbnail: The thumbnail of the Workspace.
            gallery: Gallery with images of the workspace
            user_id: Workspace keycloak user id, will be automatically be set
                to the logged in user
            publicable: Is the workspace available for non collaborators?
                Default false
            license: Workspace license
            collaborators: Collaborators who work on the workspace
            resources: Resources of the workspace
            storage: The storage of the Workspace.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TWorkspace":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> WorkspaceDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


Workspace: TWorkspace = models.Workspace  # type: ignore


class _WorkspaceCollaboratorDictBase(typing_extensions.TypedDict, total=True):
    """TypedDict for properties that are required."""

    user_id: str


class WorkspaceCollaboratorDict(_WorkspaceCollaboratorDictBase, total=False):
    """TypedDict for properties that are not required."""

    id: int


class TWorkspaceCollaborator(typing_extensions.Protocol):
    """
    SQLAlchemy model protocol.

    Workspace Collaborator of a workspace

    Attrs:
        id: The id of the WorkspaceCollaborator.
        user_id: Workspace Collaborator keycloak user id

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: int
    user_id: str

    def __init__(self, user_id: str, id: typing.Optional[int] = None) -> None:
        """
        Construct.

        Args:
            id: The id of the WorkspaceCollaborator.
            user_id: Workspace Collaborator keycloak user id

        """
        ...

    @classmethod
    def from_dict(
        cls, user_id: str, id: typing.Optional[int] = None
    ) -> "TWorkspaceCollaborator":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the WorkspaceCollaborator.
            user_id: Workspace Collaborator keycloak user id

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TWorkspaceCollaborator":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> WorkspaceCollaboratorDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


WorkspaceCollaborator: TWorkspaceCollaborator = models.WorkspaceCollaborator  # type: ignore


class _WorkspaceImageDictBase(typing_extensions.TypedDict, total=True):
    """TypedDict for properties that are required."""

    image: str


class WorkspaceImageDict(_WorkspaceImageDictBase, total=False):
    """TypedDict for properties that are not required."""

    id: int


class TWorkspaceImage(typing_extensions.Protocol):
    """
    SQLAlchemy model protocol.

    Workspace images of a workspace

    Attrs:
        id: The id of the WorkspaceImage.
        image: The image of the WorkspaceImage.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: int
    image: str

    def __init__(self, image: str, id: typing.Optional[int] = None) -> None:
        """
        Construct.

        Args:
            id: The id of the WorkspaceImage.
            image: The image of the WorkspaceImage.

        """
        ...

    @classmethod
    def from_dict(
        cls, image: str, id: typing.Optional[int] = None
    ) -> "TWorkspaceImage":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the WorkspaceImage.
            image: The image of the WorkspaceImage.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TWorkspaceImage":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> WorkspaceImageDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


WorkspaceImage: TWorkspaceImage = models.WorkspaceImage  # type: ignore


class _WorkspaceTagDictBase(typing_extensions.TypedDict, total=True):
    """TypedDict for properties that are required."""

    tag: str


class WorkspaceTagDict(_WorkspaceTagDictBase, total=False):
    """TypedDict for properties that are not required."""

    id: int


class TWorkspaceTag(typing_extensions.Protocol):
    """
    SQLAlchemy model protocol.

    Workspace tags linking to workspaces

    Attrs:
        id: The id of the WorkspaceTag.
        tag: WorkspaceTag tag

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: int
    tag: str

    def __init__(self, tag: str, id: typing.Optional[int] = None) -> None:
        """
        Construct.

        Args:
            id: The id of the WorkspaceTag.
            tag: WorkspaceTag tag

        """
        ...

    @classmethod
    def from_dict(cls, tag: str, id: typing.Optional[int] = None) -> "TWorkspaceTag":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the WorkspaceTag.
            tag: WorkspaceTag tag

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TWorkspaceTag":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> WorkspaceTagDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


WorkspaceTag: TWorkspaceTag = models.WorkspaceTag  # type: ignore


class _WorkspaceResourceDictBase(typing_extensions.TypedDict, total=True):
    """TypedDict for properties that are required."""

    name: str
    location: str
    resource_type: str


class WorkspaceResourceDict(_WorkspaceResourceDictBase, total=False):
    """TypedDict for properties that are not required."""

    id: int
    folder: typing.Optional[str]
    status: str
    timestamp_created: typing.Optional[datetime.datetime]
    timestamp_updated: typing.Optional[datetime.datetime]
    timestamp_last_opened: typing.Optional[datetime.datetime]
    workspace_id: typing.Optional[int]


class TWorkspaceResource(typing_extensions.Protocol):
    """
    SQLAlchemy model protocol.

    Workspace Resource item of a Workspace

    Attrs:
        id: The id of the WorkspaceResource.
        name: WorkspaceResource name
        location: WorkspaceResource location original location of the resource
        folder: WorkspaceResource folder where the resource will stored in the
            pvc
        status: Resource status:  * a - Available  * e - Error, not available
            * p - Pending
        timestamp_created: Date/time of creation of the WorkspaceResource
        timestamp_updated: Date/time of last updating of the WorkspaceResource
        timestamp_last_opened: Date/time of last opening of the
            WorkspaceResource
        resource_type: Resource type:  * e - Experimental  * m - Model  * g -
            Generic  * u - Unknown (to be defined)
        workspace_id: workspace_id

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: int
    name: str
    location: str
    folder: typing.Optional[str]
    status: str
    timestamp_created: typing.Optional[datetime.datetime]
    timestamp_updated: typing.Optional[datetime.datetime]
    timestamp_last_opened: typing.Optional[datetime.datetime]
    resource_type: str
    workspace_id: typing.Optional[int]

    def __init__(
        self,
        name: str,
        location: str,
        resource_type: str,
        id: typing.Optional[int] = None,
        folder: typing.Optional[str] = None,
        status: str = "p",
        timestamp_created: typing.Optional[datetime.datetime] = None,
        timestamp_updated: typing.Optional[datetime.datetime] = None,
        timestamp_last_opened: typing.Optional[datetime.datetime] = None,
        workspace_id: typing.Optional[int] = None,
    ) -> None:
        """
        Construct.

        Args:
            id: The id of the WorkspaceResource.
            name: WorkspaceResource name
            location: WorkspaceResource location original location of the
                resource
            folder: WorkspaceResource folder where the resource will stored in
                the pvc
            status: Resource status:  * a - Available  * e - Error, not
                available  * p - Pending
            timestamp_created: Date/time of creation of the WorkspaceResource
            timestamp_updated: Date/time of last updating of the
                WorkspaceResource
            timestamp_last_opened: Date/time of last opening of the
                WorkspaceResource
            resource_type: Resource type:  * e - Experimental  * m - Model  * g
                - Generic  * u - Unknown (to be defined)
            workspace_id: workspace_id

        """
        ...

    @classmethod
    def from_dict(
        cls,
        name: str,
        location: str,
        resource_type: str,
        id: typing.Optional[int] = None,
        folder: typing.Optional[str] = None,
        status: str = "p",
        timestamp_created: typing.Optional[datetime.datetime] = None,
        timestamp_updated: typing.Optional[datetime.datetime] = None,
        timestamp_last_opened: typing.Optional[datetime.datetime] = None,
        workspace_id: typing.Optional[int] = None,
    ) -> "TWorkspaceResource":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the WorkspaceResource.
            name: WorkspaceResource name
            location: WorkspaceResource location original location of the
                resource
            folder: WorkspaceResource folder where the resource will stored in
                the pvc
            status: Resource status:  * a - Available  * e - Error, not
                available  * p - Pending
            timestamp_created: Date/time of creation of the WorkspaceResource
            timestamp_updated: Date/time of last updating of the
                WorkspaceResource
            timestamp_last_opened: Date/time of last opening of the
                WorkspaceResource
            resource_type: Resource type:  * e - Experimental  * m - Model  * g
                - Generic  * u - Unknown (to be defined)
            workspace_id: workspace_id

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TWorkspaceResource":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> WorkspaceResourceDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


WorkspaceResource: TWorkspaceResource = models.WorkspaceResource  # type: ignore


class _VolumeStorageDictBase(typing_extensions.TypedDict, total=True):
    """TypedDict for properties that are required."""

    name: str


class VolumeStorageDict(_VolumeStorageDictBase, total=False):
    """TypedDict for properties that are not required."""

    id: int


class TVolumeStorage(typing_extensions.Protocol):
    """
    SQLAlchemy model protocol.

    Volume which can be connected to a workspace

    Attrs:
        id: The id of the VolumeStorage.
        name: StorageVolume name

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: int
    name: str

    def __init__(self, name: str, id: typing.Optional[int] = None) -> None:
        """
        Construct.

        Args:
            id: The id of the VolumeStorage.
            name: StorageVolume name

        """
        ...

    @classmethod
    def from_dict(cls, name: str, id: typing.Optional[int] = None) -> "TVolumeStorage":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the VolumeStorage.
            name: StorageVolume name

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TVolumeStorage":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> VolumeStorageDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


VolumeStorage: TVolumeStorage = models.VolumeStorage  # type: ignore


class OSBRepositoryContextDict(typing_extensions.TypedDict, total=False):
    """TypedDict for properties that are not required."""

    id: int
    name: typing.Optional[str]
    resources: typing.Sequence["OSBRepositoryResourceDict"]


class TOSBRepositoryContext(typing_extensions.Protocol):
    """
    SQLAlchemy model protocol.

    OSBRepository context

    Attrs:
        id: The id of the OSBRepositoryContext.
        name: Name of the repository context
        resources: List of used/referenced resources in this context

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: int
    name: typing.Optional[str]
    resources: typing.Sequence["TOSBRepositoryResource"]

    def __init__(
        self,
        id: typing.Optional[int] = None,
        name: typing.Optional[str] = None,
        resources: typing.Optional[typing.Sequence["TOSBRepositoryResource"]] = None,
    ) -> None:
        """
        Construct.

        Args:
            id: The id of the OSBRepositoryContext.
            name: Name of the repository context
            resources: List of used/referenced resources in this context

        """
        ...

    @classmethod
    def from_dict(
        cls,
        id: typing.Optional[int] = None,
        name: typing.Optional[str] = None,
        resources: typing.Optional[typing.Sequence["OSBRepositoryResourceDict"]] = None,
    ) -> "TOSBRepositoryContext":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the OSBRepositoryContext.
            name: Name of the repository context
            resources: List of used/referenced resources in this context

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TOSBRepositoryContext":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> OSBRepositoryContextDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


OSBRepositoryContext: TOSBRepositoryContext = models.OSBRepositoryContext  # type: ignore


class OSBRepositoryResourceDict(typing_extensions.TypedDict, total=False):
    """TypedDict for properties that are not required."""

    name: typing.Optional[str]
    uid: typing.Optional[str]
    id: int


class TOSBRepositoryResource(typing_extensions.Protocol):
    """
    SQLAlchemy model protocol.

    OSB Repository Resource

    Attrs:
        name: folder/file name
        uid: unique identifier for the resource in the (external) repository
        id: The id of the OSBRepositoryResource.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    name: typing.Optional[str]
    uid: typing.Optional[str]
    id: int

    def __init__(
        self,
        name: typing.Optional[str] = None,
        uid: typing.Optional[str] = None,
        id: typing.Optional[int] = None,
    ) -> None:
        """
        Construct.

        Args:
            name: folder/file name
            uid: unique identifier for the resource in the (external)
                repository
            id: The id of the OSBRepositoryResource.

        """
        ...

    @classmethod
    def from_dict(
        cls,
        name: typing.Optional[str] = None,
        uid: typing.Optional[str] = None,
        id: typing.Optional[int] = None,
    ) -> "TOSBRepositoryResource":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            name: folder/file name
            uid: unique identifier for the resource in the (external)
                repository
            id: The id of the OSBRepositoryResource.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TOSBRepositoryResource":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> OSBRepositoryResourceDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


OSBRepositoryResource: TOSBRepositoryResource = models.OSBRepositoryResource  # type: ignore


class _GITRepositoryDictBase(typing_extensions.TypedDict, total=True):
    """TypedDict for properties that are required."""

    name: str
    description: str
    repository_type: str
    repository_content_types: str
    auto_sync: bool
    uri: str
    default_context: str


class GITRepositoryDict(_GITRepositoryDictBase, total=False):
    """TypedDict for properties that are not required."""

    id: int
    user_id: typing.Optional[str]
    used_contexts: typing.Sequence["OSBRepositoryContextDict"]


class TGITRepository(typing_extensions.Protocol):
    """
    SQLAlchemy model protocol.

    GIT repository

    Attrs:
        id: The id of the GITRepository.
        name: Repository name.
        description: Repository description.
        repository_type: Repository type:   * dandi - DANDI repository   *
            figshare - FigShare repository   * github - Github repository
        repository_content_types: Comma separated set of Repository Content
            Types
        auto_sync: Auto sync of the resources
        uri: URI of the repository
        user_id: Repository keycloak user id, will be automatically be set to
            the logged in user
        used_contexts: List of contexts with used/referenced resources in this
            repository
        default_context: The default branch to show for this repository

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: int
    name: str
    description: str
    repository_type: str
    repository_content_types: str
    auto_sync: bool
    uri: str
    user_id: typing.Optional[str]
    used_contexts: typing.Sequence["TOSBRepositoryContext"]
    default_context: str

    def __init__(
        self,
        name: str,
        description: str,
        repository_type: str,
        repository_content_types: str,
        auto_sync: bool,
        uri: str,
        default_context: str,
        id: typing.Optional[int] = None,
        user_id: typing.Optional[str] = None,
        used_contexts: typing.Optional[typing.Sequence["TOSBRepositoryContext"]] = None,
    ) -> None:
        """
        Construct.

        Args:
            id: The id of the GITRepository.
            name: Repository name.
            description: Repository description.
            repository_type: Repository type:   * dandi - DANDI repository   *
                figshare - FigShare repository   * github - Github repository
            repository_content_types: Comma separated set of Repository Content
                Types
            auto_sync: Auto sync of the resources
            uri: URI of the repository
            user_id: Repository keycloak user id, will be automatically be set
                to the logged in user
            used_contexts: List of contexts with used/referenced resources in
                this repository
            default_context: The default branch to show for this repository

        """
        ...

    @classmethod
    def from_dict(
        cls,
        name: str,
        description: str,
        repository_type: str,
        repository_content_types: str,
        auto_sync: bool,
        uri: str,
        default_context: str,
        id: typing.Optional[int] = None,
        user_id: typing.Optional[str] = None,
        used_contexts: typing.Optional[
            typing.Sequence["OSBRepositoryContextDict"]
        ] = None,
    ) -> "TGITRepository":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the GITRepository.
            name: Repository name.
            description: Repository description.
            repository_type: Repository type:   * dandi - DANDI repository   *
                figshare - FigShare repository   * github - Github repository
            repository_content_types: Comma separated set of Repository Content
                Types
            auto_sync: Auto sync of the resources
            uri: URI of the repository
            user_id: Repository keycloak user id, will be automatically be set
                to the logged in user
            used_contexts: List of contexts with used/referenced resources in
                this repository
            default_context: The default branch to show for this repository

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TGITRepository":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> GITRepositoryDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


GITRepository: TGITRepository = models.GITRepository  # type: ignore


class _FigshareRepositoryDictBase(typing_extensions.TypedDict, total=True):
    """TypedDict for properties that are required."""

    name: str
    description: str
    repository_type: str
    repository_content_types: str
    auto_sync: bool
    uri: str
    url: str


class FigshareRepositoryDict(_FigshareRepositoryDictBase, total=False):
    """TypedDict for properties that are not required."""

    id: int
    user_id: typing.Optional[str]
    used_contexts: typing.Sequence["OSBRepositoryContextDict"]


class TFigshareRepository(typing_extensions.Protocol):
    """
    SQLAlchemy model protocol.

    Figshare repository

    Attrs:
        id: The id of the FigshareRepository.
        name: Repository name.
        description: Repository description.
        repository_type: Repository type:   * dandi - DANDI repository   *
            figshare - FigShare repository   * github - Github repository
        repository_content_types: Comma separated set of Repository Content
            Types
        auto_sync: Auto sync of the resources
        uri: URI of the repository
        user_id: Repository keycloak user id, will be automatically be set to
            the logged in user
        used_contexts: List of contexts with used/referenced resources in this
            repository
        url: URL of the figshare repository

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: int
    name: str
    description: str
    repository_type: str
    repository_content_types: str
    auto_sync: bool
    uri: str
    user_id: typing.Optional[str]
    used_contexts: typing.Sequence["TOSBRepositoryContext"]
    url: str

    def __init__(
        self,
        name: str,
        description: str,
        repository_type: str,
        repository_content_types: str,
        auto_sync: bool,
        uri: str,
        url: str,
        id: typing.Optional[int] = None,
        user_id: typing.Optional[str] = None,
        used_contexts: typing.Optional[typing.Sequence["TOSBRepositoryContext"]] = None,
    ) -> None:
        """
        Construct.

        Args:
            id: The id of the FigshareRepository.
            name: Repository name.
            description: Repository description.
            repository_type: Repository type:   * dandi - DANDI repository   *
                figshare - FigShare repository   * github - Github repository
            repository_content_types: Comma separated set of Repository Content
                Types
            auto_sync: Auto sync of the resources
            uri: URI of the repository
            user_id: Repository keycloak user id, will be automatically be set
                to the logged in user
            used_contexts: List of contexts with used/referenced resources in
                this repository
            url: URL of the figshare repository

        """
        ...

    @classmethod
    def from_dict(
        cls,
        name: str,
        description: str,
        repository_type: str,
        repository_content_types: str,
        auto_sync: bool,
        uri: str,
        url: str,
        id: typing.Optional[int] = None,
        user_id: typing.Optional[str] = None,
        used_contexts: typing.Optional[
            typing.Sequence["OSBRepositoryContextDict"]
        ] = None,
    ) -> "TFigshareRepository":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the FigshareRepository.
            name: Repository name.
            description: Repository description.
            repository_type: Repository type:   * dandi - DANDI repository   *
                figshare - FigShare repository   * github - Github repository
            repository_content_types: Comma separated set of Repository Content
                Types
            auto_sync: Auto sync of the resources
            uri: URI of the repository
            user_id: Repository keycloak user id, will be automatically be set
                to the logged in user
            used_contexts: List of contexts with used/referenced resources in
                this repository
            url: URL of the figshare repository

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TFigshareRepository":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> FigshareRepositoryDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


FigshareRepository: TFigshareRepository = models.FigshareRepository  # type: ignore
